List Content Comparison.


prasadswami76@gmail.com
Create a shell script to check whether Content from one list is present in another list or not

Sure, here's a shell script that will check if the content from one list is present in another list or not:

bash
Copy code
#!/bin/bash

# Define two lists
list1=("apple" "banana" "cherry" "date")
list2=("cherry" "date" "fig" "grape")

# Loop through each element in list1
for i in "${list1[@]}"
do
    # Check if the element is present in list2
    if [[ "${list2[*]}" =~ "$i" ]]
    then
        echo "$i is present in list2"
    else
        echo "$i is not present in list2"
    fi
done
In this script, we have defined two lists, list1 and list2, and we are looping through each element in list1. For each element in list1, we are checking if it is present in list2 using the =~ operator in the if statement. If the element is present in list2, we print a message saying it is present, otherwise, we print a message saying it is not present.

You can modify the script by replacing the elements in list1 and list2 with your own lists, and run it on your local machine by saving it in a file with a .sh extension, making it executable using chmod +x script.sh, and running it with ./script.sh.




prasadswami76@gmail.com
In the first list I have policycodes in random order.. In second list I have policycodes in arranged order.. I want to check if policycodes from first list is present in second list or not.. if yes then arrange thoes in second list order

Sure, here's an updated script that will check if the policy codes from the first list are present in the second list and if so, arrange them in the same order as the second list:

bash
Copy code
#!/bin/bash

# Define two lists
list1=("PC002" "PC001" "PC005" "PC003")
list2=("PC001" "PC002" "PC003" "PC004" "PC005")

# Loop through each element in list1
for i in "${list1[@]}"
do
    # Check if the element is present in list2
    if [[ "${list2[*]}" =~ "$i" ]]
    then
        # If present, add it to a new array in the order of list2
        new_list+=("$i")
    fi
done

# Print the new list
echo "${new_list[@]}"



/bin/bash

# Define two lists

list1=("C0001" "PC002" "PC001" "PC005" "PC003")

list2=("PC001" "PC002" "PC003" "PC004" "PC005")

# Get the customer id from the first list

customer_id=${list1[0]}

# Loop through each element in list1 starting from index 1

for i in "${list1[@]:1}"

do

    # Check if the element is present in list2

    if [[ "${list2[*]}" =~ "$i" ]]

    then

        # If present, add it to a new array in the order of list2

        new_list+=("$i")

    fi

done

# Put the customer id at the beginning of the new list

new_list=("$customer_id" "${new_list[@]}")

# Print the first five elements of the new list

echo "${new_list[@]:0:5}"

In this script, we have defined two lists, list1 and list2, and we are getting the customer id from the first element of list1. We then loop through each element in list1 starting from index 1, and for each element that is present in list2, we add it to a new array new_list in the order of list2.

Finally, we put the customer id at the beginning of new_list and print the first five elements of new_list.

You can modify the script by replacing the elements in list1 and list2 with your own lists and run it on your local machine by saving it in a file with a .sh extension, making it executable using chmod +x script.sh, and running it with ./script.sh.

prasadswami76@gmail.com

we add it to a new array new_list in the order of list2 please explain how code will achieve this

Sure, here's how the script will achieve adding the policy codes from list1 that are present in list2 to a new array new_list in the order of list2:

We define an empty new_list array at the beginning of the script: new_list=()

Inside the loop that iterates over the elements of list1, we use the =~ operator to check if the current element is present in list2.

If the element is present in list2, we add it to the new_list array using the += operator: new_list+=("$i"). This adds the current element to the end of the new_list array.

At the end of the loop, new_list contains all the policy codes from list1 that are present in list2, but they may not be in the order of list2.

To put the policy codes in the order of list2, we can modify the loop to iterate over the elements of list2 instead of list1, and use another loop to check if each element of list2 is present in list1 and add it to new_list in the order of list2. However, this would require a nested loop and could be less efficient if list1 and list2 are large.




we can modify the loop to iterate over the elements of list2 instead of list1, and use another loop to check if each element of list2 is present in list1 and add it to new_list in the order of 



Instead, we can use the += operator to add elements to new_list in the order of list2 by using the ${new_list[*]} syntax to expand new_list as a space-separated string, and then using the += operator to append the current element to new_list in the order of list2: new_list+=("$i"). This adds the current element to the end of new_list, but in the order of list2 because we are appending it after all the elements of new_list that are already in list2 order.

Overall, this approach allows us to add the policy codes from list1 to new_list in the order of list2 without the need for a nested loop.














ash

Copy code

#!/bin/bash

# Define two lists

list1=("PC002" "PC001" "PC005" "PC003")

list2=("PC001" "PC002" "PC003" "PC004" "PC005")

# Create a new empty array to hold the policy codes in the order of the second list

new_list=()

# Loop through each element in list2

for i in "${list2[@]}"

do

    # Loop through each element in list1 to find the index of the matching policy code

    for j in "${!list1[@]}"

    do

        if [[ "$i" == "${list1[$j]}" ]]

        then

            # If a matching policy code is found, add it to the new list in the order of list2

            new_list+=("${list1[$j]}")

            break

        fi

    done

done

# Print the new array

echo "${list1[0]} ${new_list[@]:0:4}"





!/bin/bash

# Define two lists

list1=("C001" "PC002" "PC001" "PC005" "PC003")

list2=("PC001" "PC002" "PC003" "PC004" "PC005")

# Extract the customer ID from list1

customer_id="${list1[0]}"

# Remove the first element of list1

list1=("${list1[@]:1}")

# Create a new empty array to hold the policy codes in the order of the second list

new_list=()

# Loop through each element in list2

for i in "${list2[@]}"

do

    # Loop through each element in list1 to find the index of the matching policy code

    for j in "${!list1[@]}"

    do

        if [[ "$i" == "${list1[$j]}" ]]

        then

            # If a matching policy code is found, add it to the new list in the order of list2

            new_list+=("${list1[$j]}")

            break

        fi

    done

done

# Print the customer ID followed by the first four policy codes in the order of list2

echo "$customer_id ${new_list[@]:0:4}"



#!/bin/bash

# Define the path to the CSV file

csv_file="path/to/file.csv"

# Define the second list

list2=("PC001" "PC002" "PC003" "PC004" "PC005")

# Create the target CSV file with header

echo "Customer ID, Policy Code 1, Policy Code 2, Policy Code 3, Policy Code 4" > target.csv

# Loop through each line in the CSV file

while read -r line

do

    # Extract the customer ID and policy codes from the line

    IFS=',' read -ra fields <<< "$line"

    customer_id="${fields[0]}"

    list1=("${fields[@]:1}")

    # Remove the customer ID from list1

    list1=("${list1[@]:1}")

    # Create a new empty array to hold the policy codes in the order of the second list

    new_list=()

    # Loop through each element in list2

    for i in "${list2[@]}"

    do

        # Loop through each element in list1 to find the index of the matching policy code

        for j in "${!list1[@]}"

        do

            if [[ "$i" == "${list1[$j]}" ]]

            then

                # If a matching policy code is found, add it to the new list in the order of list2

                new_list+=("${list1[$j]}")

                break

            fi

        done

    done

    # Create a new line for the target CSV file

    new_line="$customer_id,${new_list[@]:0:4}"

    

    # Add the new line to the target CSV file

    echo "$new_line" >> target.csv

done < "$csv_file"

In this modified script, we first create the target CSV file with a header using the echo command: echo "Customer ID, Policy Code 1, Policy Code 2, Policy Code 3, Policy Code 4" > target.csv. This creates a new file called target.csv and writes the header to it.

We then modify the loop to create a new line for the target CSV file using new_line="$customer_id,${new_list[@]:0:4}", which concatenates the customer ID with the first four policy codes in the order of list2 separated by commas. Finally, we add the new line to the target CSV file using echo "$new_line" >> target.csv.

With this modification, the script will write the customer ID and first four policy codes in the order of list2 for each line in the input CSV file to a new CSV file called target.csv.

ChatGPT Mar 14 Version. Free Research Preview. Our goal is to make AI systems more natural and safe to inter











import csv

# Define the path to the CSV file

csv_file = "path/to/file.csv"

# Define the second list

list2 = ["PC001", "PC002", "PC003", "PC004", "PC005"]

# Create the target CSV file with header

with open("target.csv", "w") as target_file:

    writer = csv.writer(target_file)

    writer.writerow(["Customer ID", "Policy Code 1", "Policy Code 2", "Policy Code 3", "Policy Code 4"])

    # Loop through each line in the CSV file

    with open(csv_file, "r") as file:

        reader = csv.reader(file)

        for fields in reader:

            # Extract the customer ID and policy codes from the line

            customer_id = fields[0]

            list1 = fields[1:]

            # Remove the customer ID from list1

            list1 = list1[1:]

            # Create a new empty list to hold the policy codes in the order of the second list

            new_list = []

            # Loop through each element in list2

            for i in list2:

                # Loop through each element in list1 to find the index of the matching policy code

                for j, code in enumerate(list1):

                    if i == code:

                        # If a matching policy code is found, add it to the new list in the order of list2

                        new_list.append(code)

                        break

                else:

                    # If no matching policy code is found, add a padding of 0 to the new list

                    new_list.append("0")

            # Create a new row for the target CSV file

            new_row = [customer_id] + new_list[:4]

            # Add the new row to the target CSV file

            writer.writerow(new_row)

Note that in Python, we use the csv module to read and write CSV files, and we use a with statement to ensure that the files are properly closed after we are done with them. We also use lists instead of arrays to store the policy codes, and we use the enumerate() function to loop through a list while keeping track of the index.










Run Command from Variable

prasadswami76@gmail.com

I have one command stored as a variable I want to run that command in shell script how to do that

To run a command stored in a variable in a shell script, you can use the eval command in Bash. The eval command allows you to evaluate a command that is stored in a string variable as if it were a regular command.

Here's an example:

bash

Copy code

#!/bin/bash

# Store the command in a variable

cmd="ls -l"

# Use eval to run the command

eval $cmd

In this example, the ls -l command is stored in the cmd variable. The eval command is then used to run the command stored in the cmd variable.

Note that using eval can be dangerous if the contents of the variable are not properly sanitized, as it can execute arbitrary commands. Make sure that the variable only contains a valid command that you want to run.







You're right. Here's an updated version of the script that can handle a variable number of CSV files provided as a single argument, including the case where only one CSV file is provided:

bash

Copy code

#!/bin/bash

# check that one argument has been provided

if [ "$#" -ne 1 ]; then

    echo "Usage: $0 <csv1 csv2 csv3 ...>"

    exit 1

fi

# split the argument into an array of CSV filenames

IFS=' ' read -r -a files <<< "$1"

# check that all files are CSV files

for file in "${files[@]}"; do

    if [ ! -f "$file" ] || [ "${file##*.}" != "csv" ]; then

        echo "$file is not a CSV file"

        exit 1

    fi

done

# append all CSV files to the first one

first_file="${files[0]}"

for file in "${files[@]:1}"; do

    cat "$file" >> "$first_file"

done

Save this script to a file, for example append_csv.sh, and make it executable with the command chmod +x append_csv.sh.

To use the script, run it with the names of the CSV files as a single argument separated by spaces, like this:

bash

Copy code

./append_csv.sh "csv1.csv csv2.csv csv3.csv"

The script will split the argument into an array of CSV filenames, check that all files are CSV files, and append the contents of all CSV files to the first one in the order they are provided. If only one CSV file is provided, the script will simply exit without appending anything.

ChatGPT Mar 14 Version. Free Rese




!/bin/bash

# Set path to CSV file
csv_file="table_names.csv"

# Initialize associative array to store table names and counts
declare -A counts

# Read table names from CSV file and execute Hive queries
while read -r table_name
do
    # Define Hive query using table name
    hive_query="SELECT COUNT(*) FROM $table_name;"

    # Execute Hive query and store count in associative array
    count=$(hive -e "$hive_query" | tail -1)
    counts[$table_name]=$count

    echo "Counted $count records in $table_name"
done < "$csv_file"

# Print table names and their corresponding counts
echo "Table Counts:"
for table_name in "${!counts[@]}"
do
    count=${counts[$table_name]}
    echo "$table_name: $count"
done




@echo off

set /p email=Enter your email address:
echo Your email address is %email%
echo Your email address is %email% > output.txt


:menu
cls
echo Select an option:
echo 1. Option 1
echo 2. Option 2
echo 3. Option 3
echo 4. Option 4

set /p choice=Enter your choice (1-4):

if "%choice%"=="1" (
  echo You have selected Option 1
  echo You have selected Option 1 > output.txt
) else if "%choice%"=="2" (
  echo You have selected Option 2
  echo You have selected Option 2 > output.txt
) else if "%choice%"=="3" (
  echo You have selected Option 3
  echo You have selected Option 3 > output.txt
) else if "%choice%"=="4" (
echo You have selected Option 4
  echo You have selected Option 4 > output.txt
) else (
  echo Invalid choice. Please try again.
  pause
  goto menu
)



{(1, 1, 1), (1, 1, 0), (1, 1, NULL), (1, 0, 1), (1, 0, 0), (1, 0, NULL), (1, NULL, 1), (1, NULL, 0), (1, NULL, NULL), (0, 1, 1), (0, 1, 0), (0, 1, NULL), (0, 0, 1), (0, 0, 0), (0, 0, NULL), (0, NULL, 1), (0, NULL, 0), (0, NULL, NULL), (NULL, 1, 1), (NULL, 1, 0), (NULL, 1, NULL), (NULL, 0, 1), (NULL, 0, 0), (NULL, 0, NULL), (NULL, NULL, 1), (NULL, NULL, 0), (NULL, NULL, NULL)}
{(1, 1, 1), (1, 1, 0), (1, 1, NULL), (1, 0, 1), (1, 0, 0), (1, 0, NULL), (1, NULL, 1), (1, NULL, 0), (1, NULL, NULL), (0, 1, 1), (0, 1, 0), (0, 1, NULL), (0, 0, 1), (0, 0, 0), (0, 0, NULL), (0, NULL, 1), (0, NULL, 0), (0, NULL, NULL), (NULL, 1, 1), (NULL, 1, 0), (NULL, 1, NULL), (NULL, 0, 1), (NULL, 0, 0), (NULL, 0, NULL), (NULL, NULL, 1), (NULL, NULL, 0), (NULL, NULL, NULL)}




@echo off
setlocal enabledelayedexpansion

set "infile=input.txt"
set "outfile=output.csv"

if exist "%outfile%" del "%outfile%"

for /f "tokens=* delims=" %%a in ('type "%infile%"') do (
  set "line=%%a"
  set "line=!line:	=,!"
  echo !line!>>"%outfile%"
)

echo "Conversion complete."

option batch abort
option confirm off
open sftp://username:password@example.com

# File 1
if exist C:\local\file1.txt (
    put C:\local\file1.txt /remote/path/file1.txt
    echo sh shellscript.sh > output.txt
) else (
    echo File 1 not found
)

# File 2
if exist C:\local\file2.txt (
    put C:\local\file2.txt /remote/path/file2.txt
    echo sh shellscript.sh > output.txt
) else (
    echo File 2 not found
)

# File 3
if exist C:\local\file3.txt (
    put C:\local\file3.txt /remote/path/file3.txt
    echo sh shellscript.sh > output.txt
) else (
    echo File 3 not found
)

exit



#Local outbound location
lcd C:\Outbound

# Download filenames.txt
get /remote/path/filenames.txt

# Read filenames.txt and transfer each file
option transfer binary
fileopen handle filenames.txt
while !feof handle
    filegets remotePath handle
    if !feof handle
        get %remotePath%
    end
end
fileclose handle

# Delete filenames.txt from the local machine
!del filenames.txt

exit


@echo off
set /p answer="Do you want to eat ice cream? (yes/no): "
if /i "%answer%"=="yes" (
    set /p quantity="How many ice creams do you want to eat? "
    echo You want to eat %quantity% ice cream(s).
) else (
    echo That's okay.
)

setlocal enabledelayedexpansion

set "infile=input.txt"
set "outfile=output.csv"

if exist "%outfile%" del "%outfile%"

for /f "tokens=* delims=" %%a in ('type "%infile%"') do (
  set "line=%%a"
  set "line=!line:	=,!"
  echo !line!>>"%outfile%"
)

echo "Conversion complete."

------------------------------

The error message "relaying denied from 10.122.6.125" typically indicates that the SMTP server is configured to reject relayed email messages from the IP address 10.122.6.125. Here's some information to help you understand this error:

Relaying in SMTP:

Relaying refers to the process of sending an email through one SMTP server to another, where the second server delivers the email to its intended recipient.
To prevent misuse and spam, SMTP servers are often configured to deny relaying by default.
Relaying Denied Error:

When you receive the "relaying denied" error message, it means that the SMTP server receiving the email (possibly the recipient's server) has determined that the server originating the email (10.122.6.125 in this case) is not allowed to relay messages through it.
This restriction is in place to prevent unauthorized or unsolicited emails from being relayed through the server.
Possible Causes and Solutions:

Misconfiguration: Ensure that the email client or application you're using is correctly configured to send emails through the appropriate SMTP server, and that the server's settings permit relaying.
Authentication: Some SMTP servers require authentication before allowing relaying. Ensure that you have provided the necessary authentication credentials (username and password) for the SMTP server.
IP restriction: The SMTP server may have IP-based restrictions in place, allowing relaying only from specific IP addresses or ranges. Check with the server administrator to verify if your IP address (10.122.6.125) is allowed for relaying.
SMTP server policy: The server's policy might simply disallow relaying for security reasons. In such cases, you may need to relay emails through an authorized SMTP server or contact the server administrator for further assistance.
It's worth noting that resolving relaying issues often requires administrative access and configuration changes on the SMTP server. If you're not the administrator of the server or lack the necessary privileges, it's recommended to reach out to the appropriate IT department or the server administrator for further assistance in resolving the relaying denied error.

------------------------------------------------------------------
#!/bin/bash

input_file="input.txt"
output_file="output.csv"

awk 'BEGIN { FS = "|\\^"; OFS = "," } {
  for (i = 1; i <= NF; i++) {
    printf "%s%s", $i, (i < NF ? OFS : "")
  }
  print ""
}' "$input_file" > "$output_file"
---------------------------------------------------
$dummyshell = New-Object -com "Wscript.shell"
$dummyshell.sendkeys(".")
---+++++++---+---+---------
curl --request GET \ --url https:///rest/api/3/issue/ \ --user : \ --header 'Accept: application/json'
_-------------------------------
#!/bin/bash

# List of API endpoints to check
endpoints=(
    "https://api.example.com/endpoint1"
    "https://api.example.com/endpoint2"
    "https://api.example.com/endpoint3"
)

# Create the HTML report file
report_file="api_health_report.html"
echo "<html><body>" > "$report_file"

# Iterate over the endpoints
for endpoint in "${endpoints[@]}"; do
    echo "Checking endpoint: $endpoint"
    
    # Send a GET request to the endpoint and capture the response
    response=$(curl -s -o /dev/null -w "%{http_code}" "$endpoint")

    # Check the HTTP status code
    if [[ "$response" -eq 200 ]]; then
        echo "Endpoint is running fine."
        status_msg="Endpoint is running fine."
        status_color="green"
    else
        echo "Endpoint is not running. HTTP status code: $response"
        status_msg="Endpoint is not running."
        status_color="red"
    fi

    # Add the endpoint, status, and response code to the HTML report
    echo "<p><strong>Endpoint:</strong> $endpoint</p>" >> "$report_file"
    echo "<p><strong>Status:</strong> <span style=\"color: $status_color;\">$status_msg</span></p>" >> "$report_file"
    echo "<p><strong>Response Code:</strong> $response</p>" >> "$report_file"
    echo "<hr>" >> "$report_file"

    echo "------------------------------"
done

# Close the HTML report
echo "</body></html>" >> "$report_file"

echo "HTML report generated: $report_file"
----------------------------------------------------------
(
  echo "Subject: $email_subject"
  echo "MIME-Version: 1.0"
  echo "Content-Type: text/html"
  echo "Content-Disposition: inline"
  echo "Content-Transfer-Encoding: 7bit"
  cat "$report_file"
) | 
---------------------------------------------------------------------
#!/bin/bash

# List of API endpoints to check
endpoints=(
    "https://api.example.com/endpoint1"
    "https://api.example.com/endpoint2"
    "https://api.example.com/endpoint3"
)

# Create the report file
report_file="api_health_report.txt"

# Function to display a table row
print_table_row() {
    printf "| %-40s | %-20s |\n" "$1" "$2"
}

# Function to display a table separator
print_table_separator() {
    printf "+%s+%s+\n" "------------------------------------------" "----------------------"
}

# Generate the report
echo "API Health Check Report" > "$report_file"
echo "" >> "$report_file"
print_table_separator >> "$report_file"
print_table_row "Endpoint" "Status" >> "$report_file"
print_table_separator >> "$report_file"

for endpoint in "${endpoints[@]}"; do
    echo "Checking endpoint: $endpoint"
    
    # Send a GET request to the endpoint and capture the response
    response=$(curl -s -o /dev/null -w "%{http_code}" "$endpoint")

    # Check the HTTP status code
    if [[ "$response" -eq 200 ]]; then
        print_table_row "$endpoint" "Running fine" >> "$report_file"
    else
        print_table_row "$endpoint" "Not running (HTTP $response)" >> "$report_file"
    fi

    print_table_separator >> "$report_file"
done

# Email sending configuration
email_subject="API Health Check Report"
recipient_email="example@example.com"
sender_email="sender@example.com"
smtp_server="smtp.example.com"
smtp_port="587"
smtp_username="your_username"
smtp_password="your_password"

# Send the email with the report file as an attachment
echo "Sending email..."

(
  echo "Subject: $email_subject"
  echo "To: $recipient_email"
  echo "From: $sender_email"
  echo "MIME-Version: 1.0"
  echo "Content-Type: text/plain"
  
  -----------------------------------------------------------------------------------------
  #!/bin/bash

# List of API endpoints to check
endpoints=(
    "https://api.example.com/endpoint1"
    "https://api.example.com/endpoint2"
    "https://api.example.com/endpoint3"
)

# Create the report file
report_file="api_health_report.txt"

# Function to display a table row
print_table_row() {
    printf "| %-60s | %-20s | %-13s |\n" "$1" "$2" "$3"
}

# Function to display a table separator
print_table_separator() {
    printf "+%s+%s+%s+\n" "------------------------------------------------------------" "----------------------" "---------------"
}

# Generate the report
echo "API Health Check Report" > "$report_file"
echo "" >> "$report_file"
print_table_separator >> "$report_file"
print_table_row "Endpoint" "Status" "Response Code" >> "$report_file"
print_table_separator >> "$report_file"

for endpoint in "${endpoints[@]}"; do
    echo "Checking endpoint: $endpoint"
    
    # Send a GET request to the endpoint and capture the response
    response=$(curl -s -o /dev/null -w "%{http_code}" "$endpoint")

    # Check the HTTP status code
    if [[ "$response" -eq 200 ]]; then
        print_table_row "$endpoint" "Running fine" "$response" >> "$report_file"
    else
        print_table_row "$endpoint" "Not running" "$response" >> "$report_file"
    fi

    print_table_separator >> "$report_file"
done

# Email sending configuration
email_subject="API Health Check Report"
recipient_email="example@example.com"
sender_email="sender@example.com"
smtp_server="smtp.example.com"
smtp_port="587"
smtp_username="your_username"
smtp_password="your_password"

# Send the email with the report file as an attachment
echo "Sending email..."

(
  echo "Subject: $email_subject"
  echo "To: $recipient_email"
  echo "From: $sender_email"
  echo "MIME-Version: 1.0"
  echo "Content-Type: text/plain"
  echo "Content-Disposition: attachment; filename=\"$report_file\""
  cat "$report_file"
) | sendmail -t -oi -f "$sender_email" -S smtp="$smtp_server:$smtp_port" -S smtp-use-starttls -S smtp-auth=login -S smtp-auth-user="$smtp_username" -S smtp-auth-password="$smtp_password" -S ssl-verify=ignore

echo "Email sent to $recipient_email"

# Remove the report file
rm "$report_file"
-------------------------------------------------------------------
  
  
  echo "Content-Disposition: attachment; filename=\"$report_file\""
  cat "$report_file"
) | sendmail -t -oi -f "$sender_email" -S smtp="$smtp_server:$smtp_port" -S smtp-use-starttls -S smtp-auth=login -S smtp-auth-user="$smtp_username" -S smtp-auth-password="$smtp_password" -S ssl-verify=ignore

echo "Email sent to $recipient_email"

# Remove the report file
rm "$report_file"
-------------------------------------------------------------
#!/bin/bash

# Variables
HIVE_SOURCE_QUERY="SELECT * FROM source_table;"
HIVE_TARGET_QUERY="SELECT * FROM target_table;"
BEELINE_CONNECTION_URL="jdbc:hive2://localhost:10000/default"

# Run Hive source query
SOURCE_RESULT=$(beeline -u "$BEELINE_CONNECTION_URL" -e "$HIVE_SOURCE_QUERY" --outputformat=tsv2 --showHeader=false)

# Run Hive target query
TARGET_RESULT=$(beeline -u "$BEELINE_CONNECTION_URL" -e "$HIVE_TARGET_QUERY" --outputformat=tsv2 --showHeader=false)

# Compare results
IFS=$'\n' read -r -a SOURCE_LINES <<< "$SOURCE_RESULT"
IFS=$'\n' read -r -a TARGET_LINES <<< "$TARGET_RESULT"

MISMATCHED_LINES=()
for ((i = 0; i < ${#SOURCE_LINES[@]}; i++)); do
    if [[ "${SOURCE_LINES[$i]}" != "${TARGET_LINES[$i]}" ]]; then
        MISMATCHED_LINES+=($i)
    fi
done

if [ ${#MISMATCHED_LINES[@]} -eq 0 ]; then
    RESULT_STATUS="Success"
else
    RESULT_STATUS="Failure"
fi

# Create HTML report
REPORT_FILE="comparison_report.html"

cat >"$REPORT_FILE" <<EOF
<!DOCTYPE html>
<html>
<head>
<title>Hive Query Comparison Report</title>
</head>
<body>
<h1>Hive Query Comparison Report</h1>
<h2>Source Query:</h2>
<pre>$HIVE_SOURCE_QUERY</pre>
<h2>Target Query:</h2>
<pre>$HIVE_TARGET_QUERY</pre>
<h2>Comparison Result:</h2>
<p>Result: $RESULT_STATUS</p>
<h2>Source Result:</h2>
<pre>$SOURCE_RESULT</pre>
<h2>Target Result:</h2>
<pre>$TARGET_RESULT</pre>
EOF

if [ ${#MISMATCHED_LINES[@]} -gt 0 ]; then
    echo "<h2>Mismatched Lines:</h2>" >>"$REPORT_FILE"
    echo "<ul>" >>"$REPORT_FILE"
    for line_num in "${MISMATCHED_LINES[@]}"; do
        echo "<li>Line $((line_num + 1))</li>" >>"$REPORT_FILE"
    done
    echo "</ul>" >>"$REPORT_FILE"
fi

echo "</body>" >>"$REPORT_FILE"
echo "</html>" >>"$REPORT_FILE"

echo "Comparison report generated: $REPORT_FILE"
-------------------------------------------------------
#!/bin/bash

# Variables
HIVE_SOURCE_QUERY="SELECT * FROM source_table;"
HIVE_TARGET_QUERY="SELECT * FROM target_table;"
BEELINE_CONNECTION_URL="jdbc:hive2://localhost:10000/default"

# Run Hive source query
SOURCE_RESULT=$(beeline -u "$BEELINE_CONNECTION_URL" -e "$HIVE_SOURCE_QUERY" --outputformat=tsv2 --showHeader=false)

# Run Hive target query
TARGET_RESULT=$(beeline -u "$BEELINE_CONNECTION_URL" -e "$HIVE_TARGET_QUERY" --outputformat=tsv2 --showHeader=false)

# Compare results
IFS=$'\n' read -r -a SOURCE_LINES <<< "$SOURCE_RESULT"
IFS=$'\n' read -r -a TARGET_LINES <<< "$TARGET_RESULT"

MISMATCHED_LINES=()
for ((i = 0; i < ${#SOURCE_LINES[@]}; i++)); do
    if [[ "${SOURCE_LINES[$i]}" != "${TARGET_LINES[$i]}" ]]; then
        MISMATCHED_LINES+=("$i")
    fi
done

if [ ${#MISMATCHED_LINES[@]} -eq 0 ]; then
    RESULT_STATUS="Success"
else
    RESULT_STATUS="Failure"
fi

# Create HTML report
REPORT_FILE="comparison_report.html"

cat >"$REPORT_FILE" <<EOF
<!DOCTYPE html>
<html>
<head>
<title>Hive Query Comparison Report</title>
<style>
.diff {
    color: red;
}
</style>
</head>
<body>
<h1>Hive Query Comparison Report</h1>
<h2>Source Query:</h2>
<pre>$HIVE_SOURCE_QUERY</pre>
<h2>Target Query:</h2>
<pre>$HIVE_TARGET_QUERY</pre>
<h2>Comparison Result:</h2>
<p>Result: $RESULT_STATUS</p>
<h2>Source Result:</h2>
<pre>$SOURCE_RESULT</pre>
<h2>Target Result:</h2>
<pre>$TARGET_RESULT</pre>
EOF

if [ ${#MISMATCHED_LINES[@]} -gt 0 ]; then
    echo "<h2>Mismatched Lines:</h2>" >>"$REPORT_FILE"
    for line_num in "${MISMATCHED_LINES[@]}"; do
        echo "<h3>Line $((line_num + 1)):</h3>" >>"$REPORT_FILE"
        echo "<pre>" >>"$REPORT_FILE"
        diff -u <(echo "${SOURCE_LINES[$line_num]}") <(echo "${TARGET_LINES[$line_num]}") | tail -n +4 >>"$REPORT_FILE"
        echo "</pre>" >>"$REPORT_FILE"
    done
fi

echo "</body>" >>"$REPORT_FILE"
echo "</html>" >>"$REPORT_FILE"

echo "Comparison report generated: $REPORT_FILE"
-------------------------------------------------------------------------
#!/bin/bash

# Variables
HIVE_SOURCE_QUERY="SELECT * FROM source_table;"
HIVE_TARGET_QUERY="SELECT * FROM target_table;"
BEELINE_CONNECTION_URL="jdbc:hive2://localhost:10000/default"

# Run Hive source query
SOURCE_RESULT=$(beeline -u "$BEELINE_CONNECTION_URL" -e "$HIVE_SOURCE_QUERY" --outputformat=tsv2 --showHeader=false)

# Run Hive target query
TARGET_RESULT=$(beeline -u "$BEELINE_CONNECTION_URL" -e "$HIVE_TARGET_QUERY" --outputformat=tsv2 --showHeader=false)

# Split results into arrays
IFS=$'\n' read -d '' -r -a SOURCE_LINES <<< "$SOURCE_RESULT"
IFS=$'\n' read -d '' -r -a TARGET_LINES <<< "$TARGET_RESULT"

# Get the number of lines in each result
SOURCE_COUNT=${#SOURCE_LINES[@]}
TARGET_COUNT=${#TARGET_LINES[@]}

# Compare results
if [ "$SOURCE_RESULT" == "$TARGET_RESULT" ]; then
    RESULT_STATUS="Success"
elif [ "$SOURCE_COUNT" -ne "$TARGET_COUNT" ]; then
    RESULT_STATUS="Failure: Mismatched number of records (Source: $SOURCE_COUNT, Target: $TARGET_COUNT)"
else
    MISMATCHED_LINES=()
    for ((i = 0; i < SOURCE_COUNT; i++)); do
        if [[ "${SOURCE_LINES[$i]}" != "${TARGET_LINES[$i]}" ]]; then
            MISMATCHED_LINES+=($i)
        fi
    done

    if [ ${#MISMATCHED_LINES[@]} -eq 0 ]; then
        RESULT_STATUS="Success"
    else
        RESULT_STATUS="Failure"
    fi
fi

# Create HTML report
REPORT_FILE="comparison_report.html"

cat > "$REPORT_FILE" <<EOF
<!DOCTYPE html>
<html>
<head>
<title>Hive Query Comparison Report</title>
<style>
.diff {
    color: red;
}
</style>
</head>
<body>
<h1>Hive Query Comparison Report</h1>
<h2>Source Query:</h2>
<pre>$HIVE_SOURCE_QUERY</pre>
<h2>Target Query:</h2>
<pre>$HIVE_TARGET_QUERY</pre>
<h2>Comparison Result:</h2>
<p>Result: $RESULT_STATUS</p>
<h2>Source Result:</h2>
<pre>$SOURCE_RESULT</pre>
<h2>Target Result:</h2>
<pre>$TARGET_RESULT</pre>
EOF

if [ ${#MISMATCHED_LINES[@]} -gt 0 ]; then
    echo "<h2>Mismatched Lines:</h2>" >> "$REPORT_FILE"
    for line_num in "${MISMATCHED_LINES[@]}"; do
        echo "<h3>Line $((line_num + 1)):</h3>" >> "$REPORT_FILE"
        echo "<pre>" >> "$REPORT_FILE"
        echo "${SOURCE_LINES[$line_num]}" >> "$REPORT_FILE"
        echo "<span class='diff'>" >> "$REPORT_FILE"
        echo "${TARGET_LINES[$line_num]}" >> "$REPORT_FILE"
        echo "</span>" >> "$REPORT_FILE"
        echo "</pre>" >> "$REPORT_FILE"
    done
fi

if [ "$SOURCE_COUNT" -lt "$TARGET_COUNT" ]; then
    echo "<h2>Lines present in Target but not in Source:</h2>" >> "$REPORT_FILE"
    echo "<pre>" >> "$REPORT_FILE"
    for ((i = SOURCE_COUNT; i < TARGET_COUNT; i++)); do
        echo "${TARGET_LINES[$i]}" >> "$REPORT_FILE"
    done
    echo "</pre>" >> "$REPORT_FILE"
fi

echo "</body>" >> "$REPORT_FILE"
echo "</html>" >> "$REPORT_FILE"

echo "Comparison report generated: $REPORT_FILE"
--------------------------------------------------------------------------------------------------
        # Print the merged output file with color highlighting for differences
        awk -F ',' 'NR>1{print "<tr>"; for(i=1;i<=NF;i++){if($i != $(i+NF)){print "<td><font color=\"red\">"$i"</font></td>"}else{print "<td>"$i"</td>"}} print "</tr>"}' "$output_data"
        ------------------------------------------------------------------------------------------------------
- Create table with an array of structs
CREATE TABLE my_table (
  id INT,
  persons ARRAY<STRUCT<name:STRING, age:INT>>
);

-- Insert data into the table
INSERT INTO my_table VALUES
  (1, array(named_struct('name', 'John', 'age', 25), named_struct('name', 'Alice', 'age', 30))),
  (2, array(named_struct('name', 'Bob', 'age', 28), named_struct('name', 'Jane', 'age', NULL)));

- Update age value within the array of structs
UPDATE my_table
SET persons = transform(persons, p -> IF(p.name = 'Jane', named_struct('name', p.name, 'age', 35), p))
WHERE array_contains(transform(persons, p -> p.name), 'Jane');

-- Query the updated table
SELECT * FROM my_table;
