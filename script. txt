huList Content Comparison.
"""from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello():
    return 'Hello, World!'

if __name__ == '__main__':
    app.run(debug=True, port=8080)"""

# app.py
import streamlit as st
import subprocess

def print_message(message):
    st.write(message)

def run_os_commands():
    commands = [
        'start "" "C:\\Program Files (x86)\\Cisco\\Cisco AnyConnect Secure Mobility Client\\vpnui.exe"',
        'start "" "C:\\Program Files (x86)\\Ping Identity\\PingID\\PingID.exe"',
        'start "" "C:\\Program Files\\Google\\Chrome\\Application\\chrome_proxy.exe" --profile-directory=Default --app-id=kloeccplkmphhfhfkkmjnnbopencohcp'
    ]
    
    for command in commands:
        try:
            subprocess.run(command, shell=True)
        except Exception as e:
            st.error(f"Error running command: {e}")

def open_notepad():
    try:
        subprocess.run(['notepad.exe'])
    except Exception as e:
        st.error(f"Error: {e}")

def main():
    st.title("Hello, Streamlit!")
    st.write("This is a simple Streamlit app.")
    st.write("Bhakalya")
    st.title("Streamlit Button Example")

    # Add a button to the app
    button_clicked = st.button("Open Notepad")

    # Check if the button is clicked
    if button_clicked:
        st.write("Button clicked!")
        open_notepad()
        run_os_commands()
    
    st.title("Streamlit Sidebar Buttons Example")

    # Sidebar options
    option1_button = st.sidebar.button("Option 1")
    option2_button = st.sidebar.button("Option 2")
    option3_button = st.sidebar.button("Option 3")

    # Handle button clicks
    if option1_button:
        print_message("You clicked Option 1!")
    elif option2_button:
        print_message("You clicked Option 2!")
    elif option3_button:
        print_message("You clicked Option 3!")

if __name__ == '__main__':
    main()
---------------------------------------------
Query for NUC 
SELECT
  column_name,
  CASE
    WHEN INSTR(column_name, '.') > 0 THEN
      CONCAT(
        CASE
          WHEN SUBSTRING(column_name, INSTR(column_name, '.') - 1, 1) <> '1'
          THEN SUBSTRING(column_name, 1, INSTR(column_name, '.') - 1) || '1'
          ELSE SUBSTRING(column_name, 1, INSTR(column_name, '.') - 1)
        END,
        SUBSTRING(column_name, INSTR(column_name, '.'), LENGTH(column_name))
      )
    ELSE column_name
  END AS modified_value
FROM
  your_table
WHERE
  column_name IS NOT NULL;
------------------------
list_sum = 0
for num in mylist:
	list_sum = list_sum + num
print(list_sum)
----------------------------------------------
import pandas as pd

csv_file_path = 'your_input_file.csv'
json_file_path = 'output.json'

# Read CSV file into a pandas DataFrame
df = pd.read_csv(csv_file_path)

# Convert DataFrame to JSON and save to a file
df.to_json(json_file_path, orient='records', indent=2)

print(f'Conversion successful. JSON file saved at {json_file_path}')







-----+----------+-+
#!/bin/bash

key="nram_od"
value="3"

if [ "$key" = "nram_od" ]; then
    if [ "$value" = "1" ]; then
        echo "some_line"
    elif [ "$value" = "2" ]; then
        echo "some_line"
    elif [ "$value" = "3" ]; then
        echo "some_line1"
        echo "some_line2"
    fi
elif [ "$key" = "Nuk" ]; then
    if [ "$value" != "-999.0" ]; then
        echo "some_line"
    fi
fi
---------------------------
#!/bin/bash

# Additional condition
if [ "$New_Marker" -eq 1 ] && [[ ! "0762 4208 4199" =~ $Code ]]; then
    # If Limit is a decimal value, replace the last digit before the decimal with '1'
    Limit_str=$(echo "$Limit" | tr -d '\n')
    if [[ "$Limit_str" == *.* ]]; then
        decimal_part=$(echo "$Limit_str" | cut -d'.' -f1)
        fractional_part=$(echo "$Limit_str" | cut -d'.' -f2)
        Limit="${decimal_part%?}1${fractional_part:+.$fractional_part}"
    else
        # If Limit is a natural number, use "${Limit%?}1"
        Limit="${Limit%?}1"
    fi
fi


------------------------------++
prasadswami76@gmail.com
Create a shell script to check whether Content from one list is present in another list or not

Sure, here's a shell script that will check if the content from one list is present in another list or not:

bash
Copy code
#!/bin/bash

# Define two lists
list1=("apple" "banana" "cherry" "date")
list2=("cherry" "date" "fig" "grape")

# Loop through each element in list1
for i in "${list1[@]}"
do
    # Check if the element is present in list2
    if [[ "${list2[*]}" =~ "$i" ]]
    then
        echo "$i is present in list2"
    else
        echo "$i is not present in list2"
    fi
done
In this script, we have defined two lists, list1 and list2, and we are looping through each element in list1. For each element in list1, we are checking if it is present in list2 using the =~ operator in the if statement. If the element is present in list2, we print a message saying it is present, otherwise, we print a message saying it is not present.

You can modify the script by replacing the elements in list1 and list2 with your own lists, and run it on your local machine by saving it in a file with a .sh extension, making it executable using chmod +x script.sh, and running it with ./script.sh.




prasadswami76@gmail.com
In the first list I have policycodes in random order.. In second list I have policycodes in arranged order.. I want to check if policycodes from first list is present in second list or not.. if yes then arrange thoes in second list order

Sure, here's an updated script that will check if the policy codes from the first list are present in the second list and if so, arrange them in the same order as the second list:

bash
Copy code
#!/bin/bash

# Define two lists
list1=("PC002" "PC001" "PC005" "PC003")
list2=("PC001" "PC002" "PC003" "PC004" "PC005")

# Loop through each element in list1
for i in "${list1[@]}"
do
    # Check if the element is present in list2
    if [[ "${list2[*]}" =~ "$i" ]]
    then
        # If present, add it to a new array in the order of list2
        new_list+=("$i")
    fi
done

# Print the new list
echo "${new_list[@]}"



/bin/bash

# Define two lists

list1=("C0001" "PC002" "PC001" "PC005" "PC003")

list2=("PC001" "PC002" "PC003" "PC004" "PC005")

# Get the customer id from the first list

customer_id=${list1[0]}

# Loop through each element in list1 starting from index 1

for i in "${list1[@]:1}"

do

    # Check if the element is present in list2

    if [[ "${list2[*]}" =~ "$i" ]]

    then

        # If present, add it to a new array in the order of list2

        new_list+=("$i")

    fi

done

# Put the customer id at the beginning of the new list

new_list=("$customer_id" "${new_list[@]}")

# Print the first five elements of the new list

echo "${new_list[@]:0:5}"

In this script, we have defined two lists, list1 and list2, and we are getting the customer id from the first element of list1. We then loop through each element in list1 starting from index 1, and for each element that is present in list2, we add it to a new array new_list in the order of list2.

Finally, we put the customer id at the beginning of new_list and print the first five elements of new_list.

You can modify the script by replacing the elements in list1 and list2 with your own lists and run it on your local machine by saving it in a file with a .sh extension, making it executable using chmod +x script.sh, and running it with ./script.sh.

prasadswami76@gmail.com

we add it to a new array new_list in the order of list2 please explain how code will achieve this

Sure, here's how the script will achieve adding the policy codes from list1 that are present in list2 to a new array new_list in the order of list2:

We define an empty new_list array at the beginning of the script: new_list=()

Inside the loop that iterates over the elements of list1, we use the =~ operator to check if the current element is present in list2.

If the element is present in list2, we add it to the new_list array using the += operator: new_list+=("$i"). This adds the current element to the end of the new_list array.

At the end of the loop, new_list contains all the policy codes from list1 that are present in list2, but they may not be in the order of list2.

To put the policy codes in the order of list2, we can modify the loop to iterate over the elements of list2 instead of list1, and use another loop to check if each element of list2 is present in list1 and add it to new_list in the order of list2. However, this would require a nested loop and could be less efficient if list1 and list2 are large.




we can modify the loop to iterate over the elements of list2 instead of list1, and use another loop to check if each element of list2 is present in list1 and add it to new_list in the order of 



Instead, we can use the += operator to add elements to new_list in the order of list2 by using the ${new_list[*]} syntax to expand new_list as a space-separated string, and then using the += operator to append the current element to new_list in the order of list2: new_list+=("$i"). This adds the current element to the end of new_list, but in the order of list2 because we are appending it after all the elements of new_list that are already in list2 order.

Overall, this approach allows us to add the policy codes from list1 to new_list in the order of list2 without the need for a nested loop.














ash

Copy code

#!/bin/bash

# Define two lists

list1=("PC002" "PC001" "PC005" "PC003")

list2=("PC001" "PC002" "PC003" "PC004" "PC005")

# Create a new empty array to hold the policy codes in the order of the second list

new_list=()

# Loop through each element in list2

for i in "${list2[@]}"

do

    # Loop through each element in list1 to find the index of the matching policy code

    for j in "${!list1[@]}"

    do

        if [[ "$i" == "${list1[$j]}" ]]

        then

            # If a matching policy code is found, add it to the new list in the order of list2

            new_list+=("${list1[$j]}")

            break

        fi

    done

done

# Print the new array

echo "${list1[0]} ${new_list[@]:0:4}"





!/bin/bash

# Define two lists

list1=("C001" "PC002" "PC001" "PC005" "PC003")

list2=("PC001" "PC002" "PC003" "PC004" "PC005")

# Extract the customer ID from list1

customer_id="${list1[0]}"

# Remove the first element of list1

list1=("${list1[@]:1}")

# Create a new empty array to hold the policy codes in the order of the second list

new_list=()

# Loop through each element in list2

for i in "${list2[@]}"

do

    # Loop through each element in list1 to find the index of the matching policy code

    for j in "${!list1[@]}"

    do

        if [[ "$i" == "${list1[$j]}" ]]

        then

            # If a matching policy code is found, add it to the new list in the order of list2

            new_list+=("${list1[$j]}")

            break

        fi

    done

done

# Print the customer ID followed by the first four policy codes in the order of list2

echo "$customer_id ${new_list[@]:0:4}"



#!/bin/bash

# Define the path to the CSV file

csv_file="path/to/file.csv"

# Define the second list

list2=("PC001" "PC002" "PC003" "PC004" "PC005")

# Create the target CSV file with header

echo "Customer ID, Policy Code 1, Policy Code 2, Policy Code 3, Policy Code 4" > target.csv

# Loop through each line in the CSV file

while read -r line

do

    # Extract the customer ID and policy codes from the line

    IFS=',' read -ra fields <<< "$line"

    customer_id="${fields[0]}"

    list1=("${fields[@]:1}")

    # Remove the customer ID from list1

    list1=("${list1[@]:1}")

    # Create a new empty array to hold the policy codes in the order of the second list

    new_list=()

    # Loop through each element in list2

    for i in "${list2[@]}"

    do

        # Loop through each element in list1 to find the index of the matching policy code

        for j in "${!list1[@]}"

        do

            if [[ "$i" == "${list1[$j]}" ]]

            then

                # If a matching policy code is found, add it to the new list in the order of list2

                new_list+=("${list1[$j]}")

                break

            fi

        done

    done

    # Create a new line for the target CSV file

    new_line="$customer_id,${new_list[@]:0:4}"

    

    # Add the new line to the target CSV file

    echo "$new_line" >> target.csv

done < "$csv_file"

In this modified script, we first create the target CSV file with a header using the echo command: echo "Customer ID, Policy Code 1, Policy Code 2, Policy Code 3, Policy Code 4" > target.csv. This creates a new file called target.csv and writes the header to it.

We then modify the loop to create a new line for the target CSV file using new_line="$customer_id,${new_list[@]:0:4}", which concatenates the customer ID with the first four policy codes in the order of list2 separated by commas. Finally, we add the new line to the target CSV file using echo "$new_line" >> target.csv.

With this modification, the script will write the customer ID and first four policy codes in the order of list2 for each line in the input CSV file to a new CSV file called target.csv.

ChatGPT Mar 14 Version. Free Research Preview. Our goal is to make AI systems more natural and safe to inter











import csv

# Define the path to the CSV file

csv_file = "path/to/file.csv"

# Define the second list

list2 = ["PC001", "PC002", "PC003", "PC004", "PC005"]

# Create the target CSV file with header

with open("target.csv", "w") as target_file:

    writer = csv.writer(target_file)

    writer.writerow(["Customer ID", "Policy Code 1", "Policy Code 2", "Policy Code 3", "Policy Code 4"])

    # Loop through each line in the CSV file

    with open(csv_file, "r") as file:

        reader = csv.reader(file)

        for fields in reader:

            # Extract the customer ID and policy codes from the line

            customer_id = fields[0]

            list1 = fields[1:]

            # Remove the customer ID from list1

            list1 = list1[1:]

            # Create a new empty list to hold the policy codes in the order of the second list

            new_list = []

            # Loop through each element in list2

            for i in list2:

                # Loop through each element in list1 to find the index of the matching policy code

                for j, code in enumerate(list1):

                    if i == code:

                        # If a matching policy code is found, add it to the new list in the order of list2

                        new_list.append(code)

                        break

                else:

                    # If no matching policy code is found, add a padding of 0 to the new list

                    new_list.append("0")

            # Create a new row for the target CSV file

            new_row = [customer_id] + new_list[:4]

            # Add the new row to the target CSV file

            writer.writerow(new_row)

Note that in Python, we use the csv module to read and write CSV files, and we use a with statement to ensure that the files are properly closed after we are done with them. We also use lists instead of arrays to store the policy codes, and we use the enumerate() function to loop through a list while keeping track of the index.










Run Command from Variable

prasadswami76@gmail.com

I have one command stored as a variable I want to run that command in shell script how to do that

To run a command stored in a variable in a shell script, you can use the eval command in Bash. The eval command allows you to evaluate a command that is stored in a string variable as if it were a regular command.

Here's an example:

bash

Copy code

#!/bin/bash

# Store the command in a variable

cmd="ls -l"

# Use eval to run the command

eval $cmd

In this example, the ls -l command is stored in the cmd variable. The eval command is then used to run the command stored in the cmd variable.

Note that using eval can be dangerous if the contents of the variable are not properly sanitized, as it can execute arbitrary commands. Make sure that the variable only contains a valid command that you want to run.







You're right. Here's an updated version of the script that can handle a variable number of CSV files provided as a single argument, including the case where only one CSV file is provided:

bash

Copy code

#!/bin/bash

# check that one argument has been provided

if [ "$#" -ne 1 ]; then

    echo "Usage: $0 <csv1 csv2 csv3 ...>"

    exit 1

fi

# split the argument into an array of CSV filenames

IFS=' ' read -r -a files <<< "$1"

# check that all files are CSV files

for file in "${files[@]}"; do

    if [ ! -f "$file" ] || [ "${file##*.}" != "csv" ]; then

        echo "$file is not a CSV file"

        exit 1

    fi

done

# append all CSV files to the first one

first_file="${files[0]}"

for file in "${files[@]:1}"; do

    cat "$file" >> "$first_file"

done

Save this script to a file, for example append_csv.sh, and make it executable with the command chmod +x append_csv.sh.

To use the script, run it with the names of the CSV files as a single argument separated by spaces, like this:

bash

Copy code

./append_csv.sh "csv1.csv csv2.csv csv3.csv"

The script will split the argument into an array of CSV filenames, check that all files are CSV files, and append the contents of all CSV files to the first one in the order they are provided. If only one CSV file is provided, the script will simply exit without appending anything.

ChatGPT Mar 14 Version. Free Rese




!/bin/bash

# Set path to CSV file
csv_file="table_names.csv"

# Initialize associative array to store table names and counts
declare -A counts

# Read table names from CSV file and execute Hive queries
while read -r table_name
do
    # Define Hive query using table name
    hive_query="SELECT COUNT(*) FROM $table_name;"

    # Execute Hive query and store count in associative array
    count=$(hive -e "$hive_query" | tail -1)
    counts[$table_name]=$count

    echo "Counted $count records in $table_name"
done < "$csv_file"

# Print table names and their corresponding counts
echo "Table Counts:"
for table_name in "${!counts[@]}"
do
    count=${counts[$table_name]}
    echo "$table_name: $count"
done




@echo off

set /p email=Enter your email address:
echo Your email address is %email%
echo Your email address is %email% > output.txt


:menu
cls
echo Select an option:
echo 1. Option 1
echo 2. Option 2
echo 3. Option 3
echo 4. Option 4

set /p choice=Enter your choice (1-4):

if "%choice%"=="1" (
  echo You have selected Option 1
  echo You have selected Option 1 > output.txt
) else if "%choice%"=="2" (
  echo You have selected Option 2
  echo You have selected Option 2 > output.txt
) else if "%choice%"=="3" (
  echo You have selected Option 3
  echo You have selected Option 3 > output.txt
) else if "%choice%"=="4" (
echo You have selected Option 4
  echo You have selected Option 4 > output.txt
) else (
  echo Invalid choice. Please try again.
  pause
  goto menu
)



{(1, 1, 1), (1, 1, 0), (1, 1, NULL), (1, 0, 1), (1, 0, 0), (1, 0, NULL), (1, NULL, 1), (1, NULL, 0), (1, NULL, NULL), (0, 1, 1), (0, 1, 0), (0, 1, NULL), (0, 0, 1), (0, 0, 0), (0, 0, NULL), (0, NULL, 1), (0, NULL, 0), (0, NULL, NULL), (NULL, 1, 1), (NULL, 1, 0), (NULL, 1, NULL), (NULL, 0, 1), (NULL, 0, 0), (NULL, 0, NULL), (NULL, NULL, 1), (NULL, NULL, 0), (NULL, NULL, NULL)}
{(1, 1, 1), (1, 1, 0), (1, 1, NULL), (1, 0, 1), (1, 0, 0), (1, 0, NULL), (1, NULL, 1), (1, NULL, 0), (1, NULL, NULL), (0, 1, 1), (0, 1, 0), (0, 1, NULL), (0, 0, 1), (0, 0, 0), (0, 0, NULL), (0, NULL, 1), (0, NULL, 0), (0, NULL, NULL), (NULL, 1, 1), (NULL, 1, 0), (NULL, 1, NULL), (NULL, 0, 1), (NULL, 0, 0), (NULL, 0, NULL), (NULL, NULL, 1), (NULL, NULL, 0), (NULL, NULL, NULL)}




@echo off
setlocal enabledelayedexpansion

set "infile=input.txt"
set "outfile=output.csv"

if exist "%outfile%" del "%outfile%"

for /f "tokens=* delims=" %%a in ('type "%infile%"') do (
  set "line=%%a"
  set "line=!line:	=,!"
  echo !line!>>"%outfile%"
)

echo "Conversion complete."

option batch abort
option confirm off
open sftp://username:password@example.com

# File 1
if exist C:\local\file1.txt (
    put C:\local\file1.txt /remote/path/file1.txt
    echo sh shellscript.sh > output.txt
) else (
    echo File 1 not found
)

# File 2
if exist C:\local\file2.txt (
    put C:\local\file2.txt /remote/path/file2.txt
    echo sh shellscript.sh > output.txt
) else (
    echo File 2 not found
)

# File 3
if exist C:\local\file3.txt (
    put C:\local\file3.txt /remote/path/file3.txt
    echo sh shellscript.sh > output.txt
) else (
    echo File 3 not found
)

exit



#Local outbound location
lcd C:\Outbound

# Download filenames.txt
get /remote/path/filenames.txt

# Read filenames.txt and transfer each file
option transfer binary
fileopen handle filenames.txt
while !feof handle
    filegets remotePath handle
    if !feof handle
        get %remotePath%
    end
end
fileclose handle

# Delete filenames.txt from the local machine
!del filenames.txt

exit


@echo off
set /p answer="Do you want to eat ice cream? (yes/no): "
if /i "%answer%"=="yes" (
    set /p quantity="How many ice creams do you want to eat? "
    echo You want to eat %quantity% ice cream(s).
) else (
    echo That's okay.
)

setlocal enabledelayedexpansion

set "infile=input.txt"
set "outfile=output.csv"

if exist "%outfile%" del "%outfile%"

for /f "tokens=* delims=" %%a in ('type "%infile%"') do (
  set "line=%%a"
  set "line=!line:	=,!"
  echo !line!>>"%outfile%"
)

echo "Conversion complete."

------------------------------

The error message "relaying denied from 10.122.6.125" typically indicates that the SMTP server is configured to reject relayed email messages from the IP address 10.122.6.125. Here's some information to help you understand this error:

Relaying in SMTP:

Relaying refers to the process of sending an email through one SMTP server to another, where the second server delivers the email to its intended recipient.
To prevent misuse and spam, SMTP servers are often configured to deny relaying by default.
Relaying Denied Error:

When you receive the "relaying denied" error message, it means that the SMTP server receiving the email (possibly the recipient's server) has determined that the server originating the email (10.122.6.125 in this case) is not allowed to relay messages through it.
This restriction is in place to prevent unauthorized or unsolicited emails from being relayed through the server.
Possible Causes and Solutions:

Misconfiguration: Ensure that the email client or application you're using is correctly configured to send emails through the appropriate SMTP server, and that the server's settings permit relaying.
Authentication: Some SMTP servers require authentication before allowing relaying. Ensure that you have provided the necessary authentication credentials (username and password) for the SMTP server.
IP restriction: The SMTP server may have IP-based restrictions in place, allowing relaying only from specific IP addresses or ranges. Check with the server administrator to verify if your IP address (10.122.6.125) is allowed for relaying.
SMTP server policy: The server's policy might simply disallow relaying for security reasons. In such cases, you may need to relay emails through an authorized SMTP server or contact the server administrator for further assistance.
It's worth noting that resolving relaying issues often requires administrative access and configuration changes on the SMTP server. If you're not the administrator of the server or lack the necessary privileges, it's recommended to reach out to the appropriate IT department or the server administrator for further assistance in resolving the relaying denied error.

------------------------------------------------------------------
#!/bin/bash

input_file="input.txt"
output_file="output.csv"

awk 'BEGIN { FS = "|\\^"; OFS = "," } {
  for (i = 1; i <= NF; i++) {
    printf "%s%s", $i, (i < NF ? OFS : "")
  }
  print ""
}' "$input_file" > "$output_file"
---------------------------------------------------
$dummyshell = New-Object -com "Wscript.shell"
$dummyshell.sendkeys(".")
---+++++++---+---+---------
curl --request GET \ --url https:///rest/api/3/issue/ \ --user : \ --header 'Accept: application/json'
_-------------------------------
#!/bin/bash

# List of API endpoints to check
endpoints=(
    "https://api.example.com/endpoint1"
    "https://api.example.com/endpoint2"
    "https://api.example.com/endpoint3"
)

# Create the HTML report file
report_file="api_health_report.html"
echo "<html><body>" > "$report_file"

# Iterate over the endpoints
for endpoint in "${endpoints[@]}"; do
    echo "Checking endpoint: $endpoint"
    
    # Send a GET request to the endpoint and capture the response
    response=$(curl -s -o /dev/null -w "%{http_code}" "$endpoint")

    # Check the HTTP status code
    if [[ "$response" -eq 200 ]]; then
        echo "Endpoint is running fine."
        status_msg="Endpoint is running fine."
        status_color="green"
    else
        echo "Endpoint is not running. HTTP status code: $response"
        status_msg="Endpoint is not running."
        status_color="red"
    fi

    # Add the endpoint, status, and response code to the HTML report
    echo "<p><strong>Endpoint:</strong> $endpoint</p>" >> "$report_file"
    echo "<p><strong>Status:</strong> <span style=\"color: $status_color;\">$status_msg</span></p>" >> "$report_file"
    echo "<p><strong>Response Code:</strong> $response</p>" >> "$report_file"
    echo "<hr>" >> "$report_file"

    echo "------------------------------"
done

# Close the HTML report
echo "</body></html>" >> "$report_file"

echo "HTML report generated: $report_file"
----------------------------------------------------------
(
  echo "Subject: $email_subject"
  echo "MIME-Version: 1.0"
  echo "Content-Type: text/html"
  echo "Content-Disposition: inline"
  echo "Content-Transfer-Encoding: 7bit"
  cat "$report_file"
) | 
---------------------------------------------------------------------
#!/bin/bash

# List of API endpoints to check
endpoints=(
    "https://api.example.com/endpoint1"
    "https://api.example.com/endpoint2"
    "https://api.example.com/endpoint3"
)

# Create the report file
report_file="api_health_report.txt"

# Function to display a table row
print_table_row() {
    printf "| %-40s | %-20s |\n" "$1" "$2"
}

# Function to display a table separator
print_table_separator() {
    printf "+%s+%s+\n" "------------------------------------------" "----------------------"
}

# Generate the report
echo "API Health Check Report" > "$report_file"
echo "" >> "$report_file"
print_table_separator >> "$report_file"
print_table_row "Endpoint" "Status" >> "$report_file"
print_table_separator >> "$report_file"

for endpoint in "${endpoints[@]}"; do
    echo "Checking endpoint: $endpoint"
    
    # Send a GET request to the endpoint and capture the response
    response=$(curl -s -o /dev/null -w "%{http_code}" "$endpoint")

    # Check the HTTP status code
    if [[ "$response" -eq 200 ]]; then
        print_table_row "$endpoint" "Running fine" >> "$report_file"
    else
        print_table_row "$endpoint" "Not running (HTTP $response)" >> "$report_file"
    fi

    print_table_separator >> "$report_file"
done

# Email sending configuration
email_subject="API Health Check Report"
recipient_email="example@example.com"
sender_email="sender@example.com"
smtp_server="smtp.example.com"
smtp_port="587"
smtp_username="your_username"
smtp_password="your_password"

# Send the email with the report file as an attachment
echo "Sending email..."

(
  echo "Subject: $email_subject"
  echo "To: $recipient_email"
  echo "From: $sender_email"
  echo "MIME-Version: 1.0"
  echo "Content-Type: text/plain"
  
  -----------------------------------------------------------------------------------------
  #!/bin/bash

# List of API endpoints to check
endpoints=(
    "https://api.example.com/endpoint1"
    "https://api.example.com/endpoint2"
    "https://api.example.com/endpoint3"
)

# Create the report file
report_file="api_health_report.txt"

# Function to display a table row
print_table_row() {
    printf "| %-60s | %-20s | %-13s |\n" "$1" "$2" "$3"
}

# Function to display a table separator
print_table_separator() {
    printf "+%s+%s+%s+\n" "------------------------------------------------------------" "----------------------" "---------------"
}

# Generate the report
echo "API Health Check Report" > "$report_file"
echo "" >> "$report_file"
print_table_separator >> "$report_file"
print_table_row "Endpoint" "Status" "Response Code" >> "$report_file"
print_table_separator >> "$report_file"

for endpoint in "${endpoints[@]}"; do
    echo "Checking endpoint: $endpoint"
    
    # Send a GET request to the endpoint and capture the response
    response=$(curl -s -o /dev/null -w "%{http_code}" "$endpoint")

    # Check the HTTP status code
    if [[ "$response" -eq 200 ]]; then
        print_table_row "$endpoint" "Running fine" "$response" >> "$report_file"
    else
        print_table_row "$endpoint" "Not running" "$response" >> "$report_file"
    fi

    print_table_separator >> "$report_file"
done

# Email sending configuration
email_subject="API Health Check Report"
recipient_email="example@example.com"
sender_email="sender@example.com"
smtp_server="smtp.example.com"
smtp_port="587"
smtp_username="your_username"
smtp_password="your_password"

# Send the email with the report file as an attachment
echo "Sending email..."

(
  echo "Subject: $email_subject"
  echo "To: $recipient_email"
  echo "From: $sender_email"
  echo "MIME-Version: 1.0"
  echo "Content-Type: text/plain"
  echo "Content-Disposition: attachment; filename=\"$report_file\""
  cat "$report_file"
) | sendmail -t -oi -f "$sender_email" -S smtp="$smtp_server:$smtp_port" -S smtp-use-starttls -S smtp-auth=login -S smtp-auth-user="$smtp_username" -S smtp-auth-password="$smtp_password" -S ssl-verify=ignore

echo "Email sent to $recipient_email"

# Remove the report file
rm "$report_file"
-------------------------------------------------------------------
  
  
  echo "Content-Disposition: attachment; filename=\"$report_file\""
  cat "$report_file"
) | sendmail -t -oi -f "$sender_email" -S smtp="$smtp_server:$smtp_port" -S smtp-use-starttls -S smtp-auth=login -S smtp-auth-user="$smtp_username" -S smtp-auth-password="$smtp_password" -S ssl-verify=ignore

echo "Email sent to $recipient_email"

# Remove the report file
rm "$report_file"
-------------------------------------------------------------
#!/bin/bash

# Variables
HIVE_SOURCE_QUERY="SELECT * FROM source_table;"
HIVE_TARGET_QUERY="SELECT * FROM target_table;"
BEELINE_CONNECTION_URL="jdbc:hive2://localhost:10000/default"

# Run Hive source query
SOURCE_RESULT=$(beeline -u "$BEELINE_CONNECTION_URL" -e "$HIVE_SOURCE_QUERY" --outputformat=tsv2 --showHeader=false)

# Run Hive target query
TARGET_RESULT=$(beeline -u "$BEELINE_CONNECTION_URL" -e "$HIVE_TARGET_QUERY" --outputformat=tsv2 --showHeader=false)

# Compare results
IFS=$'\n' read -r -a SOURCE_LINES <<< "$SOURCE_RESULT"
IFS=$'\n' read -r -a TARGET_LINES <<< "$TARGET_RESULT"

MISMATCHED_LINES=()
for ((i = 0; i < ${#SOURCE_LINES[@]}; i++)); do
    if [[ "${SOURCE_LINES[$i]}" != "${TARGET_LINES[$i]}" ]]; then
        MISMATCHED_LINES+=($i)
    fi
done

if [ ${#MISMATCHED_LINES[@]} -eq 0 ]; then
    RESULT_STATUS="Success"
else
    RESULT_STATUS="Failure"
fi

# Create HTML report
REPORT_FILE="comparison_report.html"

cat >"$REPORT_FILE" <<EOF
<!DOCTYPE html>
<html>
<head>
<title>Hive Query Comparison Report</title>
</head>
<body>
<h1>Hive Query Comparison Report</h1>
<h2>Source Query:</h2>
<pre>$HIVE_SOURCE_QUERY</pre>
<h2>Target Query:</h2>
<pre>$HIVE_TARGET_QUERY</pre>
<h2>Comparison Result:</h2>
<p>Result: $RESULT_STATUS</p>
<h2>Source Result:</h2>
<pre>$SOURCE_RESULT</pre>
<h2>Target Result:</h2>
<pre>$TARGET_RESULT</pre>
EOF

if [ ${#MISMATCHED_LINES[@]} -gt 0 ]; then
    echo "<h2>Mismatched Lines:</h2>" >>"$REPORT_FILE"
    echo "<ul>" >>"$REPORT_FILE"
    for line_num in "${MISMATCHED_LINES[@]}"; do
        echo "<li>Line $((line_num + 1))</li>" >>"$REPORT_FILE"
    done
    echo "</ul>" >>"$REPORT_FILE"
fi

echo "</body>" >>"$REPORT_FILE"
echo "</html>" >>"$REPORT_FILE"

echo "Comparison report generated: $REPORT_FILE"
-------------------------------------------------------
#!/bin/bash

# Variables
HIVE_SOURCE_QUERY="SELECT * FROM source_table;"
HIVE_TARGET_QUERY="SELECT * FROM target_table;"
BEELINE_CONNECTION_URL="jdbc:hive2://localhost:10000/default"

# Run Hive source query
SOURCE_RESULT=$(beeline -u "$BEELINE_CONNECTION_URL" -e "$HIVE_SOURCE_QUERY" --outputformat=tsv2 --showHeader=false)

# Run Hive target query
TARGET_RESULT=$(beeline -u "$BEELINE_CONNECTION_URL" -e "$HIVE_TARGET_QUERY" --outputformat=tsv2 --showHeader=false)

# Compare results
IFS=$'\n' read -r -a SOURCE_LINES <<< "$SOURCE_RESULT"
IFS=$'\n' read -r -a TARGET_LINES <<< "$TARGET_RESULT"

MISMATCHED_LINES=()
for ((i = 0; i < ${#SOURCE_LINES[@]}; i++)); do
    if [[ "${SOURCE_LINES[$i]}" != "${TARGET_LINES[$i]}" ]]; then
        MISMATCHED_LINES+=("$i")
    fi
done

if [ ${#MISMATCHED_LINES[@]} -eq 0 ]; then
    RESULT_STATUS="Success"
else
    RESULT_STATUS="Failure"
fi

# Create HTML report
REPORT_FILE="comparison_report.html"

cat >"$REPORT_FILE" <<EOF
<!DOCTYPE html>
<html>
<head>
<title>Hive Query Comparison Report</title>
<style>
.diff {
    color: red;
}
</style>
</head>
<body>
<h1>Hive Query Comparison Report</h1>
<h2>Source Query:</h2>
<pre>$HIVE_SOURCE_QUERY</pre>
<h2>Target Query:</h2>
<pre>$HIVE_TARGET_QUERY</pre>
<h2>Comparison Result:</h2>
<p>Result: $RESULT_STATUS</p>
<h2>Source Result:</h2>
<pre>$SOURCE_RESULT</pre>
<h2>Target Result:</h2>
<pre>$TARGET_RESULT</pre>
EOF

if [ ${#MISMATCHED_LINES[@]} -gt 0 ]; then
    echo "<h2>Mismatched Lines:</h2>" >>"$REPORT_FILE"
    for line_num in "${MISMATCHED_LINES[@]}"; do
        echo "<h3>Line $((line_num + 1)):</h3>" >>"$REPORT_FILE"
        echo "<pre>" >>"$REPORT_FILE"
        diff -u <(echo "${SOURCE_LINES[$line_num]}") <(echo "${TARGET_LINES[$line_num]}") | tail -n +4 >>"$REPORT_FILE"
        echo "</pre>" >>"$REPORT_FILE"
    done
fi

echo "</body>" >>"$REPORT_FILE"
echo "</html>" >>"$REPORT_FILE"

echo "Comparison report generated: $REPORT_FILE"
-------------------------------------------------------------------------
#!/bin/bash

# Variables
HIVE_SOURCE_QUERY="SELECT * FROM source_table;"
HIVE_TARGET_QUERY="SELECT * FROM target_table;"
BEELINE_CONNECTION_URL="jdbc:hive2://localhost:10000/default"

# Run Hive source query
SOURCE_RESULT=$(beeline -u "$BEELINE_CONNECTION_URL" -e "$HIVE_SOURCE_QUERY" --outputformat=tsv2 --showHeader=false)

# Run Hive target query
TARGET_RESULT=$(beeline -u "$BEELINE_CONNECTION_URL" -e "$HIVE_TARGET_QUERY" --outputformat=tsv2 --showHeader=false)

# Split results into arrays
IFS=$'\n' read -d '' -r -a SOURCE_LINES <<< "$SOURCE_RESULT"
IFS=$'\n' read -d '' -r -a TARGET_LINES <<< "$TARGET_RESULT"

# Get the number of lines in each result
SOURCE_COUNT=${#SOURCE_LINES[@]}
TARGET_COUNT=${#TARGET_LINES[@]}

# Compare results
if [ "$SOURCE_RESULT" == "$TARGET_RESULT" ]; then
    RESULT_STATUS="Success"
elif [ "$SOURCE_COUNT" -ne "$TARGET_COUNT" ]; then
    RESULT_STATUS="Failure: Mismatched number of records (Source: $SOURCE_COUNT, Target: $TARGET_COUNT)"
else
    MISMATCHED_LINES=()
    for ((i = 0; i < SOURCE_COUNT; i++)); do
        if [[ "${SOURCE_LINES[$i]}" != "${TARGET_LINES[$i]}" ]]; then
            MISMATCHED_LINES+=($i)
        fi
    done

    if [ ${#MISMATCHED_LINES[@]} -eq 0 ]; then
        RESULT_STATUS="Success"
    else
        RESULT_STATUS="Failure"
    fi
fi

# Create HTML report
REPORT_FILE="comparison_report.html"

cat > "$REPORT_FILE" <<EOF
<!DOCTYPE html>
<html>
<head>
<title>Hive Query Comparison Report</title>
<style>
.diff {
    color: red;
}
</style>
</head>
<body>
<h1>Hive Query Comparison Report</h1>
<h2>Source Query:</h2>
<pre>$HIVE_SOURCE_QUERY</pre>
<h2>Target Query:</h2>
<pre>$HIVE_TARGET_QUERY</pre>
<h2>Comparison Result:</h2>
<p>Result: $RESULT_STATUS</p>
<h2>Source Result:</h2>
<pre>$SOURCE_RESULT</pre>
<h2>Target Result:</h2>
<pre>$TARGET_RESULT</pre>
EOF

if [ ${#MISMATCHED_LINES[@]} -gt 0 ]; then
    echo "<h2>Mismatched Lines:</h2>" >> "$REPORT_FILE"
    for line_num in "${MISMATCHED_LINES[@]}"; do
        echo "<h3>Line $((line_num + 1)):</h3>" >> "$REPORT_FILE"
        echo "<pre>" >> "$REPORT_FILE"
        echo "${SOURCE_LINES[$line_num]}" >> "$REPORT_FILE"
        echo "<span class='diff'>" >> "$REPORT_FILE"
        echo "${TARGET_LINES[$line_num]}" >> "$REPORT_FILE"
        echo "</span>" >> "$REPORT_FILE"
        echo "</pre>" >> "$REPORT_FILE"
    done
fi

if [ "$SOURCE_COUNT" -lt "$TARGET_COUNT" ]; then
    echo "<h2>Lines present in Target but not in Source:</h2>" >> "$REPORT_FILE"
    echo "<pre>" >> "$REPORT_FILE"
    for ((i = SOURCE_COUNT; i < TARGET_COUNT; i++)); do
        echo "${TARGET_LINES[$i]}" >> "$REPORT_FILE"
    done
    echo "</pre>" >> "$REPORT_FILE"
fi

echo "</body>" >> "$REPORT_FILE"
echo "</html>" >> "$REPORT_FILE"

echo "Comparison report generated: $REPORT_FILE"
--------------------------------------------------------------------------------------------------
        # Print the merged output file with color highlighting for differences
        awk -F ',' 'NR>1{print "<tr>"; for(i=1;i<=NF;i++){if($i != $(i+NF)){print "<td><font color=\"red\">"$i"</font></td>"}else{print "<td>"$i"</td>"}} print "</tr>"}' "$output_data"
        ------------------------------------------------------------------------------------------------------
- Create table with an array of structs
CREATE TABLE my_table (
  id INT,
  persons ARRAY<STRUCT<name:STRING, age:INT>>
);

-- Insert data into the table
INSERT INTO my_table VALUES
  (1, array(named_struct('name', 'John', 'age', 25), named_struct('name', 'Alice', 'age', 30))),
  (2, array(named_struct('name', 'Bob', 'age', 28), named_struct('name', 'Jane', 'age', NULL)));

- Update age value within the array of structs
UPDATE my_table
SET persons = transform(persons, p -> IF(p.name = 'Jane', named_struct('name', p.name, 'age', 35), p))
WHERE array_contains(transform(persons, p -> p.name), 'Jane');

-- Query the updated table
SELECT * FROM my_table;






Request to Add Data


User
Create a mail saying thanks for adding data in three customers and requesting to add same data in fourth table also in polite manner.. 

ChatGPT
Subject: Gratitude for Adding Data in Three Customers and Kindly Requesting Data Addition to Fourth Table

Dear [Recipient's Name],

I hope this email finds you well. I am writing to express my sincerest gratitude for your recent efforts in adding data to the three customer tables. Your dedication and attention to detail have been invaluable in keeping our records up-to-date and maintaining the efficiency of our systems.

I am delighted to see the progress we've made with the three customer tables, and it has positively impacted our operations. Your commitment to accuracy and timeliness is truly commendable, and we are fortunate to have you as a valued member of our team.

With that said, I kindly request your assistance in adding the same data to the fourth customer table. Your expertise and familiarity with the process make you the perfect person to undertake this task. By extending your efforts to the fourth table, we can ensure that all our customer data is uniform and readily accessible across all records.

I understand that you have a busy schedule, and I genuinely appreciate your willingness to assist with this request. If you encounter any challenges or require any support, please do not hesitate to reach out to me or the relevant team members. We are here to help and support you in any way possible.

Once again, thank you for your exceptional work and your willingness to help with this additional task. Your dedication and teamwork make a significant difference, and we look forward to continuing our collaborative efforts.

Best regards,

[Your Name]
[Your Title/Position]
[Your Company/Organization]
[Your Email Address]
[Your Phone Number]


------------------+------------++-+
#!/bin/bash

if [ "$#" -ne 2 ]; then
  echo "Usage: $0 <tablename> <backuptablename>"
  exit 1
fi

tablename=$1
backuptablename=$2

# Check if the backup table already exists in Hive
backup_table_check=$(hive -S -e "SHOW TABLES LIKE '$backuptablename';")

if [ -n "$backup_table_check" ]; then
  echo "Backup table '$backuptablename' already exists in Hive."
  exit 1
fi

# Run the SHOW CREATE TABLE query and store the output
hive_output=$(hive -S -e "SHOW CREATE TABLE $tablename;")

# Check if the table exists in Hive
if [ -z "$hive_output" ]; then
  echo "Table '$tablename' not found in Hive."
  exit 1
fi

# Replace the tablename with backuptablename in the query
updated_query=$(echo "$hive_output" | sed "s/$tablename/$backuptablename/g")

# Create the backup table in Hive
hive -e "$updated_query"

if [ $? -eq 0 ]; then
  echo "Backup table '$backuptablename' created successfully."
else
  echo "Failed to create backup table '$backuptablename'."
fi

--------------------
cat ~/.ssh/id_rsa.pub | ssh username@IP address "mkdir -p ~/.ssh && chmod 700 ~/.ssh && cat >> ~/.ssh/authorized_keys"


----++-++++++++++++-++++++++
ssh://name@server.com
sftp://name@server.com
ssh -N -L 1337:localhost:1337 name@server.com
ssh -L [LOCAL_IP:]LOCAL_PORT:DESTINATION:DESTINATION_PORT [USER@]SSH_SERVER

---------------------------
{expand:title=Day 1}
  {expand-section:title=Problem}
    Insert problem description for Day 1.
  {expand-section}
  {expand-section:title=Solution}
    Insert code solution for Day 1.
  {expand-section}
{expand}




double compressing files (compressing multiple tar.gz files into one tar.gz file) can potentially cause corruption issues. Compressing an already compressed file may lead to unexpected results, as the compression algorithms might not work optimally on pre-compressed data.

Each compression step introduces additional complexity, and it can be difficult for compression algorithms to efficiently handle data that is already compressed. This can result in higher chances of data corruption, loss of data, or inflated file sizes.

To avoid such issues, it's generally recommended not to compress already compressed files unless you have specific reasons to do so and are aware of the potential risks. If you need to distribute multiple tar.gz files together, it's better to keep them separate and provide clear instructions for decompressing and using them individually.

--------------------------------------


#!/bin/bash

# Check if the correct number of arguments is provided
if [ "$#" -ne 3 ]; then
    echo "Usage: $0 <source_database> <source_table> <backup_table>"
    exit 1
fi

# Store the arguments in variables
source_database="$1"
source_table="$2"
backup_table="$3"

# Run the Hive query to get the CREATE TABLE statement
create_statement=$(hive -S -e "SHOW CREATE TABLE $source_database.$source_table")

# Check if the query executed successfully
if [ $? -eq 0 ]; then
    # Modify the CREATE TABLE statement for the backup
    modified_statement=$(echo "$create_statement" | sed "s/$source_table/$backup_table/g")

    # Create the backup table using the modified statement
    hive -e "$modified_statement"
    echo "Backup table '$backup_table' created successfully!"
else
    echo "Error running Hive query. Check if the source database and table exist."
    exit 1
fi




#!/bin/bash

# Check if the table names file exists
table_names_file="table_names.txt"

if [ ! -f "$table_names_file" ]; then
    echo "Table names file '$table_names_file' not found."
    exit 1
fi

# Read table names from the text file into an array
readarray -t table_names < "$table_names_file"

# Loop through each table
for table_name in "${table_names[@]}"; do
    # Define the output SQL file name for this table
    output_file="${table_name}_insert_queries.sql"

    # Clear the contents of the output file (if it exists)
    > "$output_file"

    # Loop to generate INSERT queries with sys_recordkey values for this table
    for ((i = 3000; i <= 8000; i++)); do
        sys_recordkey="RecordKey_$i"

        # Create the INSERT query
        insert_query="INSERT INTO $table_name (sys_recordkey) VALUES ('$sys_recordkey');"

        # Append the INSERT query to the output file
        echo "$insert_query" >> "$output_file"
    done

    # Add the 'run_sql' line to the output file
    echo "m_db run dbc -file $output_file" >> "$output_file"

    echo "SQL insert queries for $table_name generated and saved in $output_file"
done




from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
import time

driver = webdriver.Chrome()
driver.get("https://google.com")

---------------------------------
# Check if the first value of policycodes_list is in the associative array
        if [ -n "${array3[${policycodes_list[0]}]}" ]; then
            policydecision_list+=("${array3[${policycodes_list[0]}]}")
        else
            policydecision_list+=("V99")
        fi
array3=( ["PC002"]="V1" ["PC003"]="V2" ["PC001"]="V3" )


--------------------------------------

#!/bin/bash

csv_file="/Inbound/exclusion.csv"

# Define the associative array with key-value pairs
declare -A array3
array3=( ["PC002"]="V1" ["PC003"]="V2" ["PC001"]="V3" )

echo $csv_file

while IFS='|' read -r customerid policycodes previousadverseactioncode; do
    # Remove square brackets and split policycodes into an array
    policycodes_list=($(sed 's/\[//;s/\]//;s/,/\n/g;s/\"//g' <<< "$policycodes"))

    # Remove square brackets and split previousadverseactioncode into an array
    previousadverseactioncode_list=($(sed 's/\[//;s/\]//;s/,/\n/g;s/\"//g' <<< "$previousadverseactioncode"))

    echo "Customer ID: $customerid"
    policydecision_list=()  # New list to hold policy decision values
    priority_list=()  # New list to hold priority values

    # Check conditions for priority_list
    if [ "${previousadverseactioncode_list[0]}" == "NULL" ] || [ "${previousadverseactioncode_list[3]}" == "NULL" ] || [ "${previousadverseactioncode_list[4]}" == "NULL" ] || [ "${previousadverseactioncode_list[5]}" == "NULL" ] || [ "${previousadverseactioncode_list[6]}" == "NULL" ]; then
        priority_list+=(-999 -999 -999 -999)
    elif [ ${#policycodes_list[@]} -eq 0 ] && [ "${previousadverseactioncode_list[0]}" == "null" ] && [ "${previousadverseactioncode_list[1]}" == "null" ] && [ "${previousadverseactioncode_list[2]}" == "null" ] && [ "${previousadverseactioncode_list[3]}" == "null" ]; then
        priority_list+=(-998 -998 -998 -998)
    else
        # Add padding of 0s if policycodes_list has less than four values
        while [ ${#policycodes_list[@]} -lt 4 ]; do
            policycodes_list+=("0")
        done

        if [ "${previousadverseactioncode_list[@]:0:4}" == "${policycodes_list[@]:0:4}" ]; then
            priority_list+=(-997 -997 -997 -997)
        else
            priority_list+=("Unknown" "Unknown" "Unknown" "Unknown")
        fi
    fi

    echo "Priority List: ${priority_list[@]}"
done < "$csv_file"


SELECT id, name, address, phone
FROM customer
LATERAL VIEW explode(array_repeat(struct(*), 6)) exploded_table AS exploded_row;


SELECT id, name, address, phone, col
FROM customer
LATERAL VIEW explode(array('A', 'B', 'C', 'D', 'E', 'F')) exploded_table AS col;

--------------------------------------------------------------------------------


Day 1: Introduction to Linux Commands
Session 1 (30 minutes)

Introduction to Linux:

Provide a brief overview of Linux and its significance.
Explain the concept of a shell and the Bash shell.
Command Line Interface (CLI) Basics:

Discuss the basic structure of a Linux command: command, options, and arguments.
Demonstrate how to access the terminal in Linux.
Session 2 (30 minutes)

Navigating the File System:

Cover essential commands: pwd, ls, cd, mkdir, rmdir.
Explain relative and absolute paths.
File and Directory Manipulation:

Discuss commands: cp, mv, rm.
Introduce wildcard characters (*, ?).
Day 2: Advanced Linux Commands and Text Processing
Session 1 (30 minutes)

File and Text Processing with Awk and Sed:
Introduce awk for text and data extraction, covering basic syntax and examples.
Explain sed for text stream editing, focusing on search and replace operations.
Session 2 (30 minutes)

Advanced Text Processing with Awk and Sed:
Demonstrate advanced text filtering, transformation, and substitution using awk and sed.
Provide practical examples and exercises for students to practice awk and sed commands.
Day 3: Introduction to Shell Scripting
Session 1 (30 minutes)

Basics of Shell Scripting:

Define a shell script and explain its purpose.
Guide students in creating a simple shell script, explaining the script's structure.
Variables and Control Structures:

Introduce variables, data types, and their usage in shell scripts.
Cover control structures: if statements for conditional branching and loops (for and while loops).
Session 2 (30 minutes)

Functions and Script Organization:
Describe functions in shell scripting, including declaration and usage.
Emphasize organizing scripts into functions for modularity and readability.
----------------------------------------------------------------------------------

1/ Question: What is the purpose of the shebang
(#!) at the beginning of a shell script? Give an
example.
Answer: The shebang specifies the interpreter for the
script.
Example: #!/bin/bash indicates the script is using the
Bash shell.
---------------------------------------------------------
2/ Question: How can you pass arguments to a
shell script? Provide an example.
Answer: Use $1, $2, etc., for positional arguments.
Example: ./myscript.sh arg1 arg2.
---------------------------------------------------------
3/ Question: Explain the difference between single
and double quotes in shell scripting.
Answer: Single quotes preserve the literal value, while
double quotes allow variable expansion.
Example: echo 'Hello $USER' vs. echo "Hello
$USER".
---------------------------------------------------------
4/ Question: What is command substitution, and
how can you use it in a script? Provide an example.
Answer: Command substitution allows embedding
command output.
Example: current_date=$(date).
---------------------------------------------------------
5/ Question: How do you check if a file exists in a
shell script? Write a conditional example.
Answer: Use if [ -e "$filename" ]; then ... fi.
---------------------------------------------------------
6/ Question: Explain what the $? variable
represents in shell scripting.
Answer: $? holds the exit status of the last command.
0 means success, non-zero indicates an error.
---------------------------------------------------------
7/ Question: What is a here document in shell
scripting, and when would you use it? Show an
example.
Answer: A here document is used for multiline input.
Example:
cat <<EOF
This is 
a multiline
text.
EOF
---------------------------------------------------------
8/ Question: How can you iterate over files in a
directory using a for loop in Bash? Provide an
example.
Answer: Example:
for file in/path/to/dir/*; do 
	echo "$file"
done
---------------------------------------------------------
9/ Question: What is process substitution in Bash?
Give an example.
Answer: Process substitution allows treating the
output of a command as a file.
Example: diff <(command1) <(command2).
---------------------------------------------------------
10/ Question: How can you redirect both stdout and
stderr to a file in a single command?
Answer: Use command &> output.log.
---------------------------------------------------------
11/ Question: Explain the purpose of the set -e
option in a shell script.
Answer: set -e makes the script exit if any command
returns a non-zero status.
---------------------------------------------------------
12/ Question: What is a pipeline in shell scripting,
and why is it useful? Provide an example.
Answer: A pipeline connects the stdout of one
command to the stdin of another.
Example: cat file.txt | grep "pattern".
---------------------------------------------------------
13/ Question: How can you create and use
functions in a shell script? Show a function definition
and usage.
Answer: Example:
my_function() {
	echo "Hello, $1!"
}
my_function "Prasad"
---------------------------------------------------------
14/ Question: What is process forking in shell
scripting? Give an example.
Answer: Process forking is creating new processes.
Example: forked_process &.
---------------------------------------------------------
15/ Question: Explain the difference between ==
and = in a shell script's conditional statements.
Answer: == is used for string comparisons, while = is
used for variable assignments.
---------------------------------------------------------
16/ Question: How can you trap signals in a shell
script? Provide an example.
Answer: Example to trap SIGINT (Ctrl+C):
trap 'echo "Cntrl+C pressed"' INT
---------------------------------------------------------
17/ Question: What are associative arrays in Bash,
and how do you use them? Show an example.
Answer: Associative arrays allow key-value pairs.
Example:
declare -A fruits
fruits["apple]="red"
echo "Color of apple: ${fruits["apple"]}
---------------------------------------------------------
18/ Question: How can you check if a variable is
empty in a shell script?
Answer: Use if [ -z "$var" ]; then ... fi.
19/ Question: What is the purpose of the read
command in shell scripting? Provide an example.
Answer: read is used to read user input.
Example:
echo "Enter your name:"
read name 
echo "Hello, $name!"
---------------------------------------------------------
20/ Question: Explain the difference between &&
and || in conditional statements.
Answer: && executes the right command if the left
succeeds. || executes the right command if the left
fails.
---------------------------------------------------------
Time for Bonus
1/ Advanced Q8: How can you create a shell script
that runs as a daemon or background process?
A1: Use '&' to run in the background and 'nohup' to
detach from the terminal.
Example:
nohup ./myscript.sh &
---------------------------------------------------------
2/ Advanced Q5: Explain the use of 'select' in shell
scripting.
A2: 'select' provides a menu-driven interface for users.
Example:
PS3="Choose an option: "
options=("Option 1" "Option 2" "Quit")
select choice in "$(option[@]}"; do
	case $choice in 
	"Option 1")
	echo "you chose Option 1"
        ;;
	"Option 2")
	echo "you chose Option 1"
	;;
	"Quit")
	break
	;;
	*)
	echo "Invalid option"
	;;
	esac
done
---------------------------------------------------------
3/ Advanced Q4: What is process control in shell
scripting, and how can you use it?
A3: Process control involves managing background
jobs.
Example:
command1 &
command2 &
wait
---------------------------------------------------------
4/ Advanced Q4: How do you create and
manipulate associative arrays in Bash?
A4: Declare an associative array and use it like this:
declare -A fruits
fruits["apple]="red"
echo "Color of apple: ${fruits["apple"]}
---------------------------------------------------------
5/ : Explain 'awk' one-liners in shell scripting and
provide an example.
A5: 'awk' one-liners are concise commands for text
processing. Example:
awk '/pattern/' {print $2}
---------------------------------------------------------

Certainly! Here are examples for each of the shell redirection and pipe operations:

1. `>` (Greater Than) Example:
   - Redirecting the output of a command to a file.
   ```bash
   echo "Hello, World!" > output.txt
   ```
   This will create a file named `output.txt` containing the text "Hello, World!".

2. `>>` (Double Greater Than) Example:
   - Appending the output of a command to an existing file.
   ```bash
   echo "This is the second line." >> output.txt
   ```
   This will append the text "This is the second line." to the `output.txt` file created in the previous example.

3. `<` (Less Than) Example:
   - Redirecting input to a command from a file.
   ```bash
   cat < input.txt
   ```
   This will display the contents of the `input.txt` file using the `cat` command.

4. `|` (Pipe) Example:
   - Using a pipe to pass output from one command as input to another.
   ```bash
   ls | grep "example"
   ```
   This will list files in the current directory using `ls` and then filter the output using `grep` to display only the lines containing the word "example".

5. `tee` Example:
   - Using `tee` to capture output in a file and display it simultaneously.
   ```bash
   echo "This is some data." | tee output.txt
   ```
   This will display "This is some data." in the terminal and also save it to the `output.txt` file.

These examples demonstrate how each of these shell operations can be used to manipulate input and output in various ways within a shell script.


------------------------------------------------------------------------------------------

Certainly! Let's explore `sed`, `awk`, and `grep` commands in detail with examples and cover some of their common arguments.

### `sed` Command:
`sed` stands for stream editor and is used for text manipulation. It operates on a line-by-line basis and can perform tasks like search, replace, insert, and delete text.

**Basic Syntax:**
```bash
sed 's/pattern/replacement/g' filename
```

- `pattern`: The text you want to replace.
- `replacement`: The text you want to replace `pattern` with.
- `g`: Global flag, replaces all occurrences of `pattern` (not just the first one).

**Example:**
```bash
echo "Hello, World!" | sed 's/World/Universe/g'
```
This will output: `Hello, Universe!`

### `awk` Command:
`awk` is a powerful programming language mainly used for pattern scanning and processing. It operates on a per-line basis and is excellent for processing structured text data.

**Basic Syntax:**
```bash
awk '{pattern_action}' filename
```

- `{pattern_action}`: Defines patterns to match and actions to perform. Patterns are enclosed in slashes (e.g., `/pattern/`) and associated actions are inside curly braces.

**Example:**
```bash
echo "John 25\nAlice 30\nBob 28" | awk '{print $1, "is", $2, "years old."}'
```
This will output:
```
John is 25 years old.
Alice is 30 years old.
Bob is 28 years old.
```

### `grep` Command:
`grep` is used for searching text using patterns. It can search for patterns in files or output generated by other commands.

**Basic Syntax:**
```bash
grep 'pattern' filename
```

- `pattern`: The text pattern you want to search for in the file.

**Example:**
```bash
echo -e "apple\nbanana\norange\ngrape" | grep 'an'
```
This will output:
```
banana
orange
```

#### Common `grep` Arguments:
- `-i`: Ignore case (case-insensitive search).
- `-r` or `-R`: Recursive search in directories.
- `-n`: Show line numbers along with matching lines.
- `-v`: Invert match, i.e., show non-matching lines.
- `-e pattern`: Specify multiple patterns to search for.
- `-l`: Show only the names of files with matching lines.
- `-c`: Show only the count of matching lines.

**Example using arguments:**
```bash
grep -rin 'pattern' directory/
```
This will perform a case-insensitive, recursive search for 'pattern' in files inside the specified directory, showing line numbers for matches.

These examples cover the basic usage and some common arguments for `sed`, `awk`, and `grep`. Each of these commands has many more advanced features and options, so feel free to explore their respective documentation for further details.
------------------------------------------------------------
Certainly! In shell scripting, loops are used to execute a block of code repeatedly based on a condition. There are mainly three types of loops: `for`, `while`, and `until`. Additionally, `IFS` (Internal Field Separator) is not a loop but an environment variable used to split a string into fields based on a delimiter. Let's explore each one:

### 1. `for` Loop:
The `for` loop is used to iterate a specific set of statements for a predefined number of times or over a list of items.

**Syntax:**
```bash
for variable in list
do
    # Code to be executed for each item in the list
done
```

**Example:**
```bash
for i in {1..5}
do
    echo "Number: $i"
done
```
This will print numbers from 1 to 5.

### 2. `while` Loop:
The `while` loop is used to execute a set of commands as long as a specified condition is true.

**Syntax:**
```bash
while [ condition ]
do
    # Code to be executed as long as the condition is true
done
```

**Example:**
```bash
count=1
while [ $count -le 5 ]
do
    echo "Count: $count"
    ((count++))
done
```
This will print numbers from 1 to 5 using a `while` loop.

### 3. `until` Loop:
The `until` loop is used to execute a set of commands as long as a specified condition is false.

**Syntax:**
```bash
until [ condition ]
do
    # Code to be executed as long as the condition is false
done
```

**Example:**
```bash
count=1
until [ $count -gt 5 ]
do
    echo "Count: $count"
    ((count++))
done
```
This will print numbers from 1 to 5 using an `until` loop.

### `IFS` (Internal Field Separator):
`IFS` is not a loop, but an environment variable used to split a string into fields based on a delimiter.

**Example:**
```bash
sentence="This is a sentence"
IFS=" " # Setting space as the delimiter
read -ra words <<< "$sentence"
for word in "${words[@]}"
do
    echo "Word: $word"
done
```
This will split the sentence into words based on spaces and print each word separately.

These examples cover different types of loops in shell scripting (`for`, `while`, and `until`) as well as the usage of `IFS` to split strings. Each type of loop has its own specific use cases, allowing you to create flexible and powerful scripts.
----------------------------------------------------
Command substitution in shell scripting allows you to execute a command and use its output (stdout) as a value in the script. This can be achieved using backticks (\``) or `$()` syntax. Here's how it works:

### Using Backticks (\``):
```bash
variable_name=`command`
```

### Using `$()` Syntax:
```bash
variable_name=$(command)
```

Here are a few examples to illustrate command substitution:

**Example 1: Capturing Command Output**
```bash
current_date=`date`
echo "Current date and time: $current_date"
```
In this example, the `date` command is executed, and its output is stored in the `current_date` variable, which is then printed.

**Example 2: Command Substitution with a File**
```bash
file_count=$(ls -l | wc -l)
echo "Number of files in the current directory: $file_count"
```
In this example, `ls -l` lists the files in the current directory, `wc -l` counts the number of lines in the output, and the result is stored in the `file_count` variable.

**Example 3: Using Command Substitution in a Command**
```bash
echo "Today is $(date +%A), $(date +%B) $(date +%d), $(date +%Y)"
```
In this example, the `date` command is used within the `echo` statement using command substitution to print the current day, month, date, and year.

**Example 4: Command Substitution with Arithmetic**
```bash
result=$(( $(echo "10 + 20") ))
echo "Result of the arithmetic operation: $result"
```
In this example, command substitution is used inside an arithmetic operation to calculate the sum of 10 and 20.

Command substitution is a powerful feature that allows you to capture the output of commands and use it as variables or inputs for other commands within your shell scripts.
--------------------------------------------------------------------------------
In shell scripting, `if-else` statements are used to make decisions based on conditions. Here's the basic structure:

```bash
if [ condition ]
then
    # Code to be executed if the condition is true
else
    # Code to be executed if the condition is false
fi
```

The square brackets `[ ]` are used for evaluating the condition. The `then` keyword indicates the start of the code block to be executed if the condition is true. The `else` keyword is followed by the code block to be executed if the condition is false. The `fi` keyword marks the end of the `if-else` block.

Here are a few examples to illustrate `if-else` statements in shell scripting:

**Example 1: Checking if a Number is Even or Odd**
```bash
echo "Enter a number: "
read number

if [ $((number % 2)) -eq 0 ]
then
    echo "$number is even."
else
    echo "$number is odd."
fi
```

In this example, the script checks if the input number is even or odd and prints the corresponding message.

**Example 2: Comparing Strings**
```bash
expected="password123"
echo "Enter the password: "
read password

if [ "$password" = "$expected" ]
then
    echo "Access granted."
else
    echo "Access denied."
fi
```

In this example, the script checks if the entered password matches the expected password and grants or denies access accordingly.

**Example 3: Nested `if-else`**
```bash
echo "Enter your age: "
read age

if [ $age -ge 18 ]
then
    echo "You are eligible to vote."
    
    if [ $age -ge 60 ]
    then
        echo "You are also eligible for senior citizen benefits."
    fi
else
    echo "You are not eligible to vote."
fi
```

In this example, the script checks the age and provides different messages based on whether the person is eligible to vote and whether they qualify for senior citizen benefits.

`if-else` statements allow you to create conditional logic in your shell scripts, making it possible to execute different code blocks based on specific conditions.
----------------------------------------------------------------------------------------------------
In shell scripting, **arguments** refer to the values provided to a script or a function when it is executed. These arguments allow you to pass input data to your script or function, making them dynamic and versatile. 

### Arguments in Shell Script:

**Syntax for accessing script arguments:**
- `$0`: Name of the script itself.
- `$1`, `$2`, `$3`, ...: The first, second, third, and so on, arguments passed to the script.

**Example Script:**
```bash
#!/bin/bash

echo "Script name: $0"
echo "First argument: $1"
echo "Second argument: $2"
echo "All arguments: $@"
echo "Number of arguments: $#"
```

In this script, `$0` represents the script name, `$1` and `$2` represent the first and second arguments passed to the script, respectively. `$@` represents all the arguments, and `$#` represents the total number of arguments passed.

**Executing the Script:**
```bash
./script.sh arg1 arg2
```
Output:
```
Script name: ./script.sh
First argument: arg1
Second argument: arg2
All arguments: arg1 arg2
Number of arguments: 2
```

### Arguments in Functions:

**Syntax for accessing function arguments:**
- `$1`, `$2`, `$3`, ...: The first, second, third, and so on, arguments passed to the function.

**Example Function:**
```bash
#!/bin/bash

function greet {
    echo "Hello, $1!"
}

greet "Alice"
greet "Bob"
```

In this function, `$1` represents the first argument passed to the `greet` function.

**Function Execution:**
```bash
./script.sh
```
Output:
```
Hello, Alice!
Hello, Bob!
```

In the example, the `greet` function is called twice with different arguments.

You can use these arguments to make your scripts and functions more flexible and capable of handling various input scenarios. These arguments allow your scripts and functions to be reused with different data without modifying the script logic.
------------------------------------------------------------------------------
SMTP (Simple Mail Transfer Protocol) is a protocol used in email communication to send messages from a client to a server or between servers. You can use the `telnet` command in a shell script to interact with an SMTP server and send emails using the SMTP protocol. Below is an example of how you can send an email using SMTP in a shell script using the `telnet` command with verbose output.

**Shell Script to Send Email using SMTP:**

```bash
#!/bin/bash

# SMTP Server Details
SMTP_SERVER="smtp.example.com"
SMTP_PORT="25"
SENDER_EMAIL="sender@example.com"
RECIPIENT_EMAIL="recipient@example.com"

# Email Content
EMAIL_SUBJECT="Test Email"
EMAIL_BODY="This is a test email sent using SMTP in shell script."

# Connect to SMTP server using telnet
{
    sleep 1
    echo "EHLO example.com"
    sleep 1
    echo "MAIL FROM:<$SENDER_EMAIL>"
    sleep 1
    echo "RCPT TO:<$RECIPIENT_EMAIL>"
    sleep 1
    echo "DATA"
    sleep 1
    echo "Subject: $EMAIL_SUBJECT"
    echo -e "$EMAIL_BODY"
    echo "."
    echo "QUIT"
} | telnet -c "$SMTP_SERVER" "$SMTP_PORT"

echo "Email sent successfully."
```

In this script:

1. Replace `"smtp.example.com"` with your SMTP server address.
2. Set `"25"` as the port number for unencrypted SMTP communication. For encrypted SMTP (SMTPS) use port `"587"` or `"465"` depending on the encryption method (STARTTLS or SSL/TLS).
3. Set `"sender@example.com"` and `"recipient@example.com"` with the sender and recipient email addresses, respectively.
4. Set the `EMAIL_SUBJECT` and `EMAIL_BODY` variables with the desired email subject and body.

The script uses `telnet` to connect to the SMTP server and sends SMTP commands to send the email. The `-c` option in `telnet` enables character mode, allowing you to send commands non-interactively. The `sleep` commands are added to give the server some time to respond between each command.

Make sure to customize the script with your SMTP server details and run it in a shell environment that allows network connections. Note that this example does not handle authentication or encryption, which are typically required in real-world scenarios.
---------------------------------------------------------
Certainly! The `curl` command in shell scripting is a powerful tool for making HTTP requests to various services, including APIs. Below is an example of how you can use `curl` in a shell script to interact with the Jira API for demonstration purposes.

### Prerequisites:
Before using the Jira API, make sure you have the following information:
- Jira Base URL
- API endpoint you want to access
- Authentication credentials (usually in the form of username and API token)

### Example Shell Script Using `curl` and Jira API:

```bash
#!/bin/bash

# Jira API Details
JIRA_BASE_URL="https://your-jira-instance.atlassian.net"
JIRA_API_ENDPOINT="/rest/api/2/issue"
USERNAME="your_username"
API_TOKEN="your_api_token"

# Issue Key to Fetch (replace 'PROJECT-123' with a valid Jira issue key)
ISSUE_KEY="PROJECT-123"

# API Request URL
API_URL="$JIRA_BASE_URL$JIRA_API_ENDPOINT/$ISSUE_KEY"

# Curl command to fetch Jira issue details
curl -u "$USERNAME:$API_TOKEN" -X GET -H "Content-Type: application/json" "$API_URL"
```

In this script:

- `JIRA_BASE_URL` is the base URL of your Jira instance.
- `JIRA_API_ENDPOINT` is the specific API endpoint you want to access (in this case, fetching a specific issue).
- `USERNAME` is your Jira username.
- `API_TOKEN` is your Jira API token. You can generate an API token in your Jira account settings.
- `ISSUE_KEY` is the key of the Jira issue you want to fetch. Replace it with a valid issue key from your Jira instance.

The `curl` command makes a GET request to the specified API endpoint with basic authentication using your Jira username and API token. The response from the Jira API will be printed to the terminal.

Make sure to update the variables (`JIRA_BASE_URL`, `JIRA_API_ENDPOINT`, `USERNAME`, `API_TOKEN`, and `ISSUE_KEY`) with your own Jira details before running the script. This script demonstrates how to fetch issue details, but you can modify it to perform other operations based on the Jira API documentation.
---------------------------------------------------------------------
Birthday Mail
Certainly! Below is an example of a shell script that reads a CSV file with pipe-delimited fields containing name, email, and birthday information. The script checks if today's date matches any of the birthdays in the file and sends a birthday wish email to the respective person using the SMTP protocol. Please replace `smtp_server`, `smtp_port`, `smtp_username`, `smtp_password` with your SMTP server details and provide the correct path to your CSV file.

```bash
#!/bin/bash

# SMTP Server details
smtp_server="your_smtp_server"
smtp_port="your_smtp_port"
smtp_username="your_smtp_username"
smtp_password="your_smtp_password"

# CSV file path
csv_file="path/to/your/csvfile.csv"

# Get current date in format MM-DD
current_date=$(date +%m-%d)

# Read the CSV file and send birthday wishes
while IFS='|' read -r name email birthday; do
    # Extract month and day from the birthday field (MM-DD)
    birthday_month_day=$(echo "$birthday" | cut -d'-' -f2-)

    # Check if current date matches birthday
    if [ "$current_date" == "$birthday_month_day" ]; then
        # Send birthday wish email
        echo "Subject: Happy Birthday, $name!
From: Your Name <your_email@example.com>
To: $email

Dear $name,

Happy Birthday! 🎉🎂

Best regards,
Your Name" | \
        /usr/sbin/sendmail -S "$smtp_server:$smtp_port" \
                            -au"$smtp_username" -ap"$smtp_password" \
                            -f"your_email@example.com" "$email"
        
        echo "Birthday wish sent to $name ($email)"
    fi
done < "$csv_file"
```

Make sure to update the SMTP server details, CSV file path, and customize the email message as needed. Please note that sending emails via SMTP may require appropriate permissions and configurations on your server. Also, ensure that the `sendmail` command is available on your system. You might need to adjust the command if you are using a different mail sending method.
---------------------------------------------------------

I have csv pipe delimited file with name|mail-id|birthday. create a shell script which will check the current date if currecnt date matches with the birthday then we will send the birthday wish to the person via mail using smtp protocol



-------------------------------------------------------
<dependency>  
    <groupId>com.sparkjava</groupId>  
    <artifactId>spark-core</artifactId>  
    <version>2.9.3</version>  
</dependency>  
-----------------------------
import static spark.Spark.*;  
public class HelloWorld   
{  
    public static void main(String[] args)   
{  
        get("/hello", (req, res) -> "Hello World");  
    }  
}  

https://www.javatpoint.com/spark-java

SparkSession spark = SparkSession.builder().master("yarn").appName("Application").enableHiveSupport().getOrCreate();
Dataset<Row> ds = spark.read().parquet(filename);

---------------------------------------------------

import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;
import org.apache.spark.sql.SparkSession;

public class ParquetFileReader {
    public static void main(String[] args) {
        // Create a SparkSession
        SparkSession spark = SparkSession.builder()
                .appName("ParquetFileReader")
                .master("local[*]") // You can change the master URL based on your Spark cluster configuration
                .getOrCreate();

        // Specify the path to the Parquet file
        String parquetFilePath = "path/to/your/parquet/file";

        // Read the Parquet file into a DataFrame
        Dataset<Row> parquetFile = spark.read().parquet(parquetFilePath);

        // Show the schema of the DataFrame
        parquetFile.printSchema();

        // Show the data in the DataFrame
        parquetFile.show();

        // Stop the SparkSession
        spark.stop();
    }
}

-----+----------------+---------------
no give java code

To execute SQL queries on a dataset in Spark using Java, you can follow these steps:

1. Create a `SparkSession` object:

```java
SparkSession spark = SparkSession.builder()
    .appName("Java Spark SQL basic example")
    .config("spark.some.config.option", "some-value")
    .getOrCreate();
```

2. Read the dataset and create a temporary view:

```java
Dataset<Row> df = spark.read().json("path/to/dataset.json");
df.createOrReplaceTempView("people");
```

3. Run an SQL query on the dataset:

```java
Dataset<Row> sqlDF = spark.sql("SELECT * FROM people WHERE age > 30");
sqlDF.show();
```

Here's the complete code:

```java
import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;
import org.apache.spark.sql.SparkSession;

public class SparkSQLExample {
    public static void main(String[] args) {
        SparkSession spark = SparkSession.builder()
            .appName("Java Spark SQL basic example")
            .config("spark.some.config.option", "some-value")
            .getOrCreate();

        Dataset<Row> df = spark.read().json("path/to/dataset.json");
        df.createOrReplaceTempView("people");

        Dataset<Row> sqlDF = spark.sql("SELECT * FROM people WHERE age > 30");
        sqlDF.show();
    }
}
```

Make sure to replace `"path/to/dataset.json"` with the actual path to your dataset. This code reads a JSON file and performs a simple SQL query to filter the data based on the age column. You can modify the SQL query to suit your needs.
------------------------------------------------------------------

#!/bin/bash

# Function to check the zip file and its contents
checkZipFile() {
    local directory="/path/to/your/directory"
    local log_file="/path/to/your/logfile.log"
    local graph_count=0
    
    

    # Call the function to run .pset files
    runGraphs "$directory" "$log_file" graph_count
    
    # Log the total number of graphs processed along with the directory path
    echo "$(date) - Total graphs processed from $directory : $graph_count" >> "$log_file"
}

# Function to run .pset files
runGraphs() {
    local dir="$1"
    local log_file="$2"
    local -n count_ref="$3"
    
    # Loop through .pset files and run 'air run {path}'
    for pset_file in "$dir"/*.pset; do
        if [ -e "$pset_file" ]; then
            echo "Running air run for file: $pset_file"
            
            # Run the graph and capture the output in a variable
            graph_output=$(air run "$pset_file")
            
            # Check if the last line contains '+++++COMPLETE+++++'
            if [[ "$graph_output" == *'+++++COMPLETE+++++'* ]]; then
                echo "Graph execution successful."
            else
                echo "Graph execution failed."
                # Log the message
                echo "$(date) - Graph execution failed for file: $pset_file" >> "$log_file"
            fi
            
            # Increment the graph count
            ((count_ref++))
        else
            echo "No .pset files found in the directory."
            # Log the message
            echo "$(date) - No .pset files found in the directory." >> "$log_file"
        fi
    done
}

# Call the function to check the zip file and run .pset files
checkZipFile
--------------------------------------------------------------
#!/bin/bash

# Specify the location to check for zip file
file_location="/path/to/your/directory"

# Log function to store messages in a log file
log() {
    local log_file="/path/to/your/logfile.log"
    echo "$(date) - $1" >> "$log_file"
}

# Check if zip file exists
if [ -e "$file_location/abc-$(date +"%d-%m-%Y").zip" ]; then
    echo "Zip file found: abc-$(date +"%d-%m-%Y").zip"
    
    # Extract date from zip file name
    zip_date=$(date -d "$(date +"%d-%m-%Y")" +"%d-%m-%Y")

    # Extract text files from the zip and check their names for the same date
    unzip -l "$file_location/abc-$zip_date.zip" '*.txt' | awk '{print $4}' | while read -r filename; do
        # Extract date from text file name
        text_file_date=$(echo "$filename" | grep -oP '\d{2}-\d{2}-\d{4}')
        if [ "$text_file_date" == "$zip_date" ]; then
            echo "Text file $filename has the correct date."
        else
            echo "Error: Text file $filename does not have the correct date."
            # Log the message
            log "Error: Text file $filename does not have the correct date."
        fi
    done

else
    echo "Zip file not found: abc-$(date +"%d-%m-%Y").zip"
    # Log the message
    log "Zip file not found: abc-$(date +"%d-%m-%Y").zip"
fi
--------------------------------------------------------
#!/bin/bash

# Function to log messages
log() {
    local log_file="/path/to/your/logfile.log"
    echo "$(date) - $1" >> "$log_file"
}

# Function to check the zip file and its contents
checkZipFile() {
    local directory="/path/to/your/directory"
    local graph_count=0
    
    # ... (your existing code for checking zip files)

    # Call the function to run .pset files
    runGraphs "$directory" graph_count
    
    # Log the total number of graphs processed along with the directory path
    log "Total graphs processed from $directory: $graph_count"
}

# Function to run .pset files
runGraphs() {
    local dir="$1"
    local -n count_ref="$2"
    
    # Loop through .pset files and run 'air run {path}'
    for pset_file in "$dir"/*.pset; do
        if [ -e "$pset_file" ]; then
            echo "Running air run for file: $pset_file"
            
            # Run the graph and capture the output in a variable
            graph_output=$(air run "$pset_file")
            
            # Check if the last line contains '+++++COMPLETE+++++'
            if [[ "$graph_output" == *'+++++COMPLETE+++++'* ]]; then
                echo "Graph execution successful."
            else
                echo "Graph execution failed."
                # Log the message
                log "Graph execution failed for file: $pset_file"
            fi
            
            # Increment the graph count
            ((count_ref++))
        else
            echo "No .pset files found in the directory."
            # Log the message
            log "No .pset files found in the directory."
        fi
    done
}

# Call the function to check the zip file and run .pset files
checkZipFile
-----------------------------------------------------
for file in $(unzip -l archive.zip | awk '{print $NF}'); do
  last_line=$(unzip -p archive.zip "$file" | tail -n 1)
  echo "$file: $last_line"
done
---------------------------------------------------------
To create temporary log files in Linux, you can use the mktemp utility available on most Linux systems
This utility creates unique temporary files within the containing directory. By default, running mktemp with no arguments will create a temporary file in /tmp
TMPFILE=$(mktemp /tmp/foo-XXXXX)
echo "Hello world" >> $TMPFILE  # Append some text to the file
cat $TMPFILE                    # Print the contents of the file
rm $TMPFILE         

TMPFILE=$(mktemp /tmp/foo-XXXXXX)
trap "rm -f $TMPFILE" EXIT
When keeping big temporary files, we might want to do some housekeeping in case our script fails.

We can do this using the trap command, which allows us to run some code when an exit code is detected:
$ FILENAME=$(mktemp --tmpdir=/tmp temp_file-XXXXXXXXXX.txt)
$ echo $FILENAME
/tmp/temp_file-HIitKZc0MT.txt
-------------------------------------------------------------
extracted_date=$(echo "$filename" | sed -n 's/.*_\([0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}\)_.*/\1/p')

-------------------------------------------------------------
#!/bin/bash

# Record start time
start_time=$(date "+%Y-%m-%d %H:%M:%S")

# Your existing shell script commands here
# For example:
# command1
# command2
# ...

# Record end time
end_time=$(date "+%Y-%m-%d %H:%M:%S")

# Find files generated between start and end time
find /path/to/your/directory -type f -newermt "$start_time" ! -newermt "$end_time"
------------------------------------------------------------------
#!/bin/bash

# Prompt user for name
read -p "Enter your name: " name

# Prompt user for rating
read -p "Please rate our training out of 5: " rating

# Check if rating is less than 2.5 and double it
if (( $(awk 'BEGIN {print ("'$rating'" < 2.5)}') )); then
    rating=$(awk 'BEGIN {print "'$rating'" * 2}')
fi

# Prompt user for comments
read -p "Please provide your comments (Press Enter to skip): " comments

# Send feedback via email
echo -e "Name: $name\nRating: $rating\nComments: $comments" | mail -s "Training Feedback" -a "From: your_email@example.com" your_email@example.com

# Thank you message
echo "Thank you, $name, for participating in the training! Your feedback has been submitted."
----------------------------------------------------------------
better_compare(){
    echo -e "give me some sunshine :filename: \c"
    read -r filename
    read -n1 -p "Press any key to continue..."

    # Ask the user for source query type
    echo -e "\nChoose the source query type:"
    echo "1. Hive"
    echo "2. Oracle"
    echo "3. File Path"
    read -r -p "Enter your choice: " source_query_type

    case $source_query_type in
        1) 
            source_query_command="bline --outputformat=csv2 -f source_query.hql > source_data.csv"
            ;;
        2) 
            source_query_command="m_db unload 'source_query' > source_data.csv"
            ;;
        3) 
            read -r -p "Enter the file path for the source query: " source_query_path
            source_query_command="cat '$source_query_path' > source_data.csv"
            ;;
        *)
            echo "Invalid choice for source query type. Exiting."
            exit 1
            ;;
    esac

    # Ask the user for target query type
    echo -e "\nChoose the target query type:"
    echo "1. Hive"
    echo "2. Oracle"
    echo "3. File Path"
    read -r -p "Enter your choice: " target_query_type

    case $target_query_type in
        1) 
            target_query_command="bline --outputformat=csv2 -f target_query.hql > target_data.csv"
            ;;
        2) 
            target_query_command="m_db unload 'target_query' > target_data.csv"
            ;;
        3) 
            read -r -p "Enter the file path for the target query: " target_query_path
            target_query_command="cat '$target_query_path' > target_data.csv"
            ;;
        *)
            echo "Invalid choice for target query type. Exiting."
            exit 1
            ;;
    esac

    # Execute the source and target query commands
    eval "$source_query_command"
    eval "$target_query_command"

    # Call the second part of the function for comparison and HTML report creation
    run_query_create_evidence_part2
}
-------------------------------------------------------------------------
better_compare(){
    echo -e "give me some sunshine :filename: \c"
    read -r filename
    read -n1 -p "Press any key to continue..."

    # Ask the user for source query type
    echo -e "\nChoose the source query type:"
    echo "1. Oracle"
    echo "2. Hive"
    echo "3. File Path"
    read -r -p "Enter your choice: " source_query_type

    case $source_query_type in
        1) 
            echo "Enter your Oracle source query.Press Cntrl + D after writing the query."
            cat > source_query.hql
            ;;
        2) 
            echo "Enter your Hive source query.Press Cntrl + D after writing the query."
            cat > source_query.hql
            ;;
        3) 
            read -r -p "Enter the file path for the source query: " source_query_path
            cat "$source_query_path" > source_query.hql
            ;;
        *)
            echo "Invalid choice. Exiting."
            exit 1
            ;;
    esac

    # Ask the user for target query type
    echo -e "\nChoose the target query type:"
    echo "1. Oracle"
    echo "2. Hive"
    echo "3. File Path"
    read -r -p "Enter your choice: " target_query_type

    case $target_query_type in
        1) 
            echo "Enter your Oracle target query.Press Cntrl + D after writing the query."
            cat > target_query.hql
            ;;
        2) 
            echo "Enter your Hive target query.Press Cntrl + D after writing the query."
            cat > target_query.hql
            ;;
        3) 
            read -r -p "Enter the file path for the target query: " target_query_path
            cat "$target_query_path" > target_query.hql
            ;;
        *)
            echo "Invalid choice. Exiting."
            exit 1
            ;;
    esac

    run_query_create_evidence
}
--------------------------------------------------------------------

SELECT
  CASE
    WHEN SUM(CASE WHEN element = 1 THEN 1 ELSE 0 END) >= 9 THEN 'customer is adverse'
    ELSE 'customer is not adverse'
  END AS customer_status
FROM
  your_table_name
LATERAL VIEW EXPLODE(numbers_array) exploded_table AS element;
-------------------------------------------------------------------
#!/bin/bash

# Input file path
input_file="input.csv"

# Process the input file and generate the output
while IFS='|' read -r customer_id shopping_data; do
    # Count the number of zero shopping months using awk
    zero_months_count=$(echo "$shopping_data" | awk -F',' '{count=0; for(i=1;i<=NF;i++) if($i==0) count++; print count}')
    
    # Determine if the number of zero shopping months is at least 9
    if [ "$zero_months_count" -ge 9 ]; then
        has_at_least_nine_zeros=1
        additional_column_value=1331
    else
        has_at_least_nine_zeros=0
        additional_column_value=0
    fi
    
    # Output format: customer_id|number_of_zero_shopping_months|has_at_least_nine_zeros|additional_column_value
    echo "$customer_id|$zero_months_count|$has_at_least_nine_zeros|$additional_column_value"
done < "$input_file"
--------------------------------------------------------------------
#!/bin/bash

# Check if the user provided a file containing hostnames
if [ -z "$1" ]; then
    echo "Please provide a file containing hostnames."
    exit 1
fi

# Read hostnames from the provided file and resolve them to IP addresses
while IFS= read -r hostname; do
    ip=$(nslookup "$hostname" | awk '/^Address: / { print $2 }')
    echo "Hostname: $hostname, IP Address: $ip"
done < "$1"
--------+------------

hadoop fs -ls /path/to/your/hdfs/directory | grep -E '^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}$' | sort -t ' ' -k 1,2,3 -r | head -1

------------------------------
hadoop fs -ls /path/to/hdfs/directory | awk '{print $6, $7, $8}' | sort -k1,1n -k2,2M -k3,3n | tail -n 1 | awk '{print $3}'

---------------------------
#!/bin/bash

# Record start time
start_time=$(date "+%Y-%m-%d %H:%M:%S")

# Your existing shell script commands here
# For example:
# command1
# command2
# ...

# Record end time
end_time=$(date "+%Y-%m-%d %H:%M:%S")

# Find files generated between start and end time
files_to_zip=$(find /path/to/your/directory -type f -newermt "$start_time" ! -newermt "$end_time")

# Create a variable with newline characters replaced by spaces
files_to_be_removed=$(echo "$files_to_zip" | tr '\n' ' ')

# Zip the files
zip -n "abc$USER.zip" $files_to_zip

# Store filename and line count in /tmp/downstream_files_count.txt
for file in $files_to_be_removed; do
    line_count=$(wc -l < "$file")
    echo "Filename: $file, Line Count: $line_count" >> /tmp/downstream_files_count.txt
done

# Delete the files generated in the given time period
rm $files_to_be_removed
# Count the number of files
file_count=$(echo "$files_to_zip" | wc -l)

# Zip the files
zip -n "abc$USER.zip" $files_to_zip

# Store filename and line count in /tmp/downstream_files_count.txt
echo "Number of files generated in the given time period: $file_count" > /tmp/downstream_files_count.txt

for file in $files_to_be_removed; do
    basename_file=$(basename "$file")
    line_count=$(wc -l < "$file")
    echo "Filename: $basename_file, Line Count: $line_count" >> /tmp/downstream_files_count.txt
done
------------------------------------------------------------------------
from itertools import product

# Define the possible values for each variable
New_Marker_values = [0, 1]
Code_values = ['0762', '4208', '4199', '9876', '6546', '2354', '1295']
Limit_values = [-1000, -1001, -1002, -1003, -1004, -1005, -1006, -1007, -1008, -1009, -2000]

# Generate the Cartesian product of the possible values
sample_space = list(product(New_Marker_values, Code_values, Limit_values))

# Print all scenarios
for idx, scenario in enumerate(sample_space, start=1):
    New_Marker, Code, Limit = scenario
    print(f"{idx}. New_Marker={New_Marker}, Code={Code}, Limit={Limit}")


---------------------------
number=12.65

if [[ $number == *.* ]]; then
    integer_part=$(echo "$number" | awk -F'.' '{print $1}')
    decimal_part=$(echo "$number" | awk -F'.' '{print $2}')
else
    integer_part=$number
    decimal_part=""
fi
